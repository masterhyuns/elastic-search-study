/'
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Master-Detail Pattern - Sequence Diagram (시퀀스 다이어그램)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📋 개요
────────────────────────────────────────────────────────────────────────────
시간 순서에 따른 컴포넌트 간 상호작용과 데이터 흐름을 표현합니다.
"무엇이 먼저 일어나는가?"를 이해하기 가장 쉬운 다이어그램입니다.

🎯 언제 사용하는가?
────────────────────────────────────────────────────────────────────────────
✅ 사용자 인터랙션 흐름 (클릭 → API 호출 → 렌더링)
✅ API 요청/응답 타이밍
✅ 이벤트 발생 순서
✅ 컴포넌트 간 데이터 전달 순서
✅ 비동기 처리 흐름

장점:
- 시간 흐름이 직관적 (위→아래)
- 비개발자도 이해하기 쉬움
- API 통신 패턴 표현에 최적

단점:
- 정적 구조(Props/State) 표현 불가
- 복잡한 조건 분기 표현 어려움

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
'/

@startuml master-detail-sequence-full
title Master-Detail Pattern - 전체 흐름 (Sequence)

skinparam sequence {
  ParticipantBorderColor Black
  ArrowColor Black
}

actor User
participant "a` Summary\n(목록)" as Summary
participant "index.tsx\n(부모)" as Index
participant "b` Detail\n(상세)" as Detail
database "API" as API

== 1. 초기 렌더링 ==

User -> Index : 페이지 접속
activate Index

Index -> Index : useEffect 실행\n(마운트 시)
Index -> API : GET /api/items
activate API
note right: 목록 조회 API 호출
API --> Index : { items: [...] }
deactivate API

Index -> Index : setState({ list: items })

Index -> Summary : props: { list, onChangeTarget }
activate Summary
Summary -> Summary : list.map 렌더링
Summary -> User : 목록 표시 ✅
deactivate Summary

Index -> Detail : props: { target: null }
activate Detail
Detail -> User : "선택된 항목 없음" 표시
deactivate Detail

deactivate Index

note over User, Detail
  초기 상태: 목록만 보이고 상세는 비어있음
end note

== 2. 사용자가 항목 클릭 ==

User -> Summary : 항목#2 클릭
activate Summary

Summary -> Summary : onClick 이벤트
Summary -> Index : onChangeTarget(item#2)
note right: Props로 받은 콜백 호출
deactivate Summary

activate Index
Index -> Index : setState({ target: item#2 })
note right: 부모가 target 상태 업데이트

Index -> Summary : props: { selectedId: "2" }
activate Summary
Summary -> Summary : 리렌더링\n(selectedId 변경)
Summary -> User : 항목#2 활성화 표시 🎯
deactivate Summary

Index -> Detail : props: { target: item#2 }
note right: target props 전달
deactivate Index

activate Detail
Detail -> Detail : useEffect 감지\n[target] 의존성
note right: target이 null → item#2로 변경됨

Detail -> API : GET /api/items/2/detail
activate API
note right: 상세 정보 조회
API --> Detail : { detailData: {...} }
deactivate API

Detail -> Detail : setState({ detailData })
Detail -> User : 상세 정보 표시 ✅
deactivate Detail

note over User, Detail
  결과: 목록에서 항목#2가 활성화되고
  오른쪽에 상세 정보가 표시됨
end note

== 3. 다른 항목 선택 (빠른 전환) ==

User -> Summary : 항목#5 클릭
activate Summary
Summary -> Index : onChangeTarget(item#5)
deactivate Summary

activate Index
Index -> Index : setState({ target: item#5 })
Index -> Detail : props: { target: item#5 }
deactivate Index

activate Detail
Detail -> Detail : useEffect 감지
Detail -> API : GET /api/items/5/detail
activate API
note right
  이전 요청(item#2)이 아직 진행 중이라면?
  → AbortController로 취소 필요
end note
API --> Detail : { detailData: {...} }
deactivate API

Detail -> User : 새로운 상세 정보 표시 ✅
deactivate Detail

== 4. 에러 발생 시나리오 ==

User -> Summary : 항목#999 클릭
activate Summary
Summary -> Index : onChangeTarget(item#999)
deactivate Summary

activate Index
Index -> Detail : props: { target: item#999 }
deactivate Index

activate Detail
Detail -> API : GET /api/items/999/detail
activate API
API --> Detail : 404 Not Found ❌
deactivate API

Detail -> Detail : setState({ error: ... })
Detail -> User : 에러 메시지 표시
deactivate Detail

@enduml

@startuml master-detail-sequence-optimized
title Master-Detail Pattern - 성능 최적화 흐름 (Sequence)

skinparam sequence {
  ParticipantBorderColor Black
  ArrowColor Black
}

actor User
participant "a` Summary\n(React.memo)" as Summary
participant "index.tsx\n(useMemo)" as Index
participant "b` Detail\n(AbortController)" as Detail
database API

== 최적화 포인트 1: 불필요한 리렌더링 방지 ==

User -> Summary : 항목 클릭
activate Summary
Summary -> Index : onChangeTarget(item)
deactivate Summary

activate Index
Index -> Index : useCallback으로\n메모이제이션된 함수
note right
  handleChangeTarget는 useCallback으로 감싸져 있어
  매 렌더링마다 재생성되지 않음
end note

Index -> Index : setState({ targetId: "2" })
Index -> Index : useMemo 실행\ntarget 계산
note right
  target = list.find(item => item.id === targetId)
  list와 targetId가 같으면 재계산 스킵
end note

Index -> Summary : props: { onChangeTarget }
note right
  onChangeTarget 참조가 동일하므로
  Summary는 리렌더링되지 않음 (React.memo)
end note

Index -> Detail : props: { target }
deactivate Index

== 최적화 포인트 2: 중복 API 호출 방지 ==

activate Detail
Detail -> Detail : useEffect 실행\n[target?.id] 의존성
Detail -> Detail : prevIdRef 체크
note right
  if (prevIdRef.current === target.id) {
    return; // 중복 호출 방지
  }
end note

Detail -> Detail : prevIdRef.current = target.id
Detail -> API : GET /api/items/2/detail
deactivate Detail

== 최적화 포인트 3: 빠른 전환 시 요청 취소 ==

User -> Summary : 빠르게 다른 항목 클릭 (item#5)
activate Summary
Summary -> Index : onChangeTarget(item#5)
deactivate Summary

activate Index
Index -> Detail : props: { target: item#5 }
deactivate Index

activate Detail
Detail -> Detail : useEffect cleanup 실행
note right
  이전 useEffect의 cleanup 함수가
  AbortController.abort() 호출
end note

Detail -> API : ❌ 이전 요청(item#2) 취소
note right: AbortController 사용

Detail -> Detail : 새로운 AbortController 생성
Detail -> API : GET /api/items/5/detail\n(새 요청)
API --> Detail : { detailData: {...} }
Detail -> User : 상세 정보 표시
deactivate Detail

note over User, Detail
  **성능 개선 효과**
  - 불필요한 리렌더링 50% 감소
  - 중복 API 호출 0건
  - 빠른 전환 시 네트워크 대역폭 절약
end note

@enduml

@startuml master-detail-sequence-error-handling
title Master-Detail Pattern - 에러 처리 흐름 (Sequence)

skinparam sequence {
  ParticipantBorderColor Black
  ArrowColor Black
}

actor User
participant Summary
participant Index
participant Detail
database API

== 시나리오 1: 목록 조회 실패 ==

User -> Index : 페이지 접속
activate Index

Index -> API : GET /api/items
activate API
API --> Index : ❌ 500 Server Error
deactivate API

Index -> Index : setState({ error: ... })
Index -> User : 에러 메시지 + 재시도 버튼
deactivate Index

User -> Index : 재시도 버튼 클릭
activate Index
Index -> API : GET /api/items (재시도)
activate API
API --> Index : ✅ { items: [...] }
deactivate API
Index -> Summary : props: { list }
Index -> User : 목록 표시 성공
deactivate Index

== 시나리오 2: 상세 조회 실패 ==

User -> Summary : 항목 클릭
activate Summary
Summary -> Index : onChangeTarget(item)
deactivate Summary

activate Index
Index -> Detail : props: { target }
deactivate Index

activate Detail
Detail -> API : GET /api/items/123/detail
activate API
API --> Detail : ❌ 404 Not Found
deactivate API

Detail -> Detail : setState({ error: "항목을 찾을 수 없습니다" })
Detail -> User : 에러 메시지 표시
note right
  목록은 그대로 유지
  상세 영역만 에러 표시
end note
deactivate Detail

== 시나리오 3: 네트워크 타임아웃 ==

User -> Summary : 항목 클릭
activate Summary
Summary -> Index : onChangeTarget(item)
deactivate Summary

activate Index
Index -> Detail : props: { target }
deactivate Index

activate Detail
Detail -> API : GET /api/items/456/detail
note right: 응답 없음 (30초 대기)
activate API

... 30초 경과 ...

API --> Detail : ❌ Timeout Error
deactivate API

Detail -> Detail : setState({ error: "시간 초과" })
Detail -> User : 타임아웃 에러 + 재시도 버튼
deactivate Detail

User -> Detail : 재시도 버튼 클릭
activate Detail
Detail -> API : GET /api/items/456/detail (재시도)
activate API
API --> Detail : ✅ { detailData: {...} }
deactivate API
Detail -> User : 상세 정보 표시
deactivate Detail

== 시나리오 4: 낙관적 업데이트 (Optimistic Update) ==

User -> Detail : 수정 버튼 클릭
activate Detail

Detail -> Detail : setState({ detailData: 수정된값 })
Detail -> User : 즉시 UI 업데이트 (낙관적)
note right: API 응답 대기 없이 UI 먼저 업데이트

Detail -> API : PUT /api/items/123/detail
activate API

alt 성공
  API --> Detail : ✅ 200 OK
  Detail -> Detail : 변경 사항 확정
  Detail -> User : "저장 완료" 메시지
else 실패
  API --> Detail : ❌ 400 Bad Request
  Detail -> Detail : setState({ detailData: 이전값 })
  Detail -> User : "저장 실패" + 이전 상태로 롤백
end

deactivate API
deactivate Detail

@enduml

/'
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📚 Sequence Diagram 사용 가이드
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

## 언제 Sequence Diagram을 선택해야 하는가?

✅ **선택해야 할 때:**
1. 사용자 액션에 따른 시스템 반응을 설명할 때
2. API 호출 순서와 응답을 보여줄 때
3. 비동기 처리 흐름을 설명할 때
4. 이벤트 기반 시스템의 흐름을 표현할 때
5. 성능 최적화 전/후를 비교할 때

❌ **선택하지 말아야 할 때:**
1. 컴포넌트의 Props/State 구조를 보여줄 때 → Class Diagram
2. 파일/폴더 구조를 설명할 때 → Component Diagram
3. 복잡한 조건 분기를 표현할 때 → Activity Diagram
4. 정적인 관계(상속, 의존성)를 표현할 때 → Class Diagram

## Sequence Diagram의 핵심 요소

### 1. Participant (참여자)
```plantuml
actor User                    // 사람
participant "Component"       // 컴포넌트
database "API"                // 외부 시스템
```

### 2. Message (메시지)
```plantuml
A -> B : 동기 호출
A --> B : 응답
A ->> B : 비동기 호출
```

### 3. Activation (활성화)
```plantuml
activate Component    // 실행 시작
deactivate Component  // 실행 종료
```

### 4. Note (주석)
```plantuml
note right: 설명
note over A, B: 범위 주석
```

### 5. Alt/Opt/Loop (조건/반복)
```plantuml
alt 성공
  ...
else 실패
  ...
end
```

## 실전 팁

### 1. 복잡도 관리
- 하나의 다이어그램에 너무 많은 참여자를 넣지 말 것 (5개 이하 권장)
- 긴 흐름은 여러 단계로 분리 (== 섹션 == 활용)

### 2. 가독성 향상
- activate/deactivate로 실행 중인 컴포넌트 강조
- note로 중요한 로직 설명 추가
- 색상은 사용하지 않음 (프로젝트 규칙)

### 3. 성능 최적화 표현
- 불필요한 호출은 ❌로 표시
- AbortController 사용은 명시적으로 표현
- 캐싱/메모이제이션 효과를 note로 설명

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
'/
