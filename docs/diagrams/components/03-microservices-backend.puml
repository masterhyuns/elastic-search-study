@startuml 마이크로서비스_백엔드_아키텍처
' ============================================================
' 템플릿: 마이크로서비스 백엔드 컴포넌트
' 사용 사례:
'   - 도메인별 서비스 분리 설계
'   - API Gateway 패턴
'   - 서비스 간 통신 (동기/비동기)
' ============================================================

!theme plain
skinparam backgroundColor white

' ───────────────────────────────────────────────────────────
' 스타일 정의
' ───────────────────────────────────────────────────────────
skinparam component {
  BackgroundColor<<gateway>> #F5F5F5
  BackgroundColor<<service>> #E0E0E0
  BackgroundColor<<infrastructure>> #C0C0C0
  BackgroundColor<<database>> #A0A0A0
  BorderColor Black
  FontSize 10
}

skinparam database {
  BackgroundColor #D0D0D0
  BorderColor Black
}

skinparam queue {
  BackgroundColor #E8E8E8
  BorderColor Black
}

' ───────────────────────────────────────────────────────────
' Client Layer
' ───────────────────────────────────────────────────────────
actor "Web Client" as web
actor "Mobile Client" as mobile
actor "Admin Portal" as admin

' ───────────────────────────────────────────────────────────
' API Gateway Layer
' ───────────────────────────────────────────────────────────
package "API Gateway Layer" {
  [API Gateway] <<gateway>> {
    + 라우팅
    + 인증/인가
    + Rate Limiting
    + 로드 밸런싱
  }

  [Auth Service] <<gateway>> {
    + JWT 발급
    + Token 검증
    + RBAC
  }
}

' ───────────────────────────────────────────────────────────
' Microservices Layer (Domain-Driven Design)
' ───────────────────────────────────────────────────────────
package "User Domain" {
  [User Service] <<service>> {
    + 사용자 CRUD
    + 프로필 관리
    + 권한 관리
  }

  database "User DB\n(PostgreSQL)" as userDB
}

package "Order Domain" {
  [Order Service] <<service>> {
    + 주문 생성
    + 주문 조회
    + 상태 관리
  }

  database "Order DB\n(PostgreSQL)" as orderDB
}

package "Payment Domain" {
  [Payment Service] <<service>> {
    + 결제 처리
    + 환불 관리
    + PG 연동
  }

  database "Payment DB\n(PostgreSQL)" as paymentDB
}

package "Notification Domain" {
  [Notification Service] <<service>> {
    + 이메일 발송
    + SMS 전송
    + Push 알림
  }

  database "Notification Log\n(MongoDB)" as notificationDB
}

package "Inventory Domain" {
  [Inventory Service] <<service>> {
    + 재고 관리
    + 재고 차감
    + 재고 조회
  }

  database "Inventory DB\n(PostgreSQL)" as inventoryDB
}

' ───────────────────────────────────────────────────────────
' Infrastructure Layer
' ───────────────────────────────────────────────────────────
package "Infrastructure" {
  queue "Message Queue\n(Kafka/RabbitMQ)" as mq
  [Service Discovery\n(Consul/Eureka)] <<infrastructure>>
  [Config Server] <<infrastructure>>
  database "Cache\n(Redis)" as cache
}

' ───────────────────────────────────────────────────────────
' 관계: Client → Gateway
' ───────────────────────────────────────────────────────────
web --> "API Gateway" : HTTPS
mobile --> "API Gateway" : HTTPS
admin --> "API Gateway" : HTTPS

' ───────────────────────────────────────────────────────────
' 관계: Gateway → Services (동기 통신)
' ───────────────────────────────────────────────────────────
"API Gateway" --> "Auth Service" : 인증 요청
"API Gateway" --> "User Service" : REST API
"API Gateway" --> "Order Service" : REST API
"API Gateway" --> "Payment Service" : REST API
"API Gateway" --> "Inventory Service" : REST API

' ───────────────────────────────────────────────────────────
' 서비스 간 통신 (동기)
' ───────────────────────────────────────────────────────────
"Order Service" --> "User Service" : 사용자 정보 조회\n(REST)
"Order Service" --> "Inventory Service" : 재고 확인\n(REST)
"Payment Service" --> "Order Service" : 주문 정보 조회\n(REST)

' ───────────────────────────────────────────────────────────
' 서비스 간 통신 (비동기 - 메시지 큐)
' ───────────────────────────────────────────────────────────
"Order Service" ..> mq : OrderCreated\nEvent 발행
"Payment Service" ..> mq : PaymentCompleted\nEvent 발행
"Inventory Service" ..> mq : StockChanged\nEvent 발행

mq ..> "Notification Service" : 이벤트 구독
mq ..> "Inventory Service" : OrderCreated\n구독 (재고 차감)
mq ..> "Order Service" : PaymentCompleted\n구독 (상태 변경)

' ───────────────────────────────────────────────────────────
' Database 연결
' ───────────────────────────────────────────────────────────
"User Service" --> userDB
"Order Service" --> orderDB
"Payment Service" --> paymentDB
"Notification Service" --> notificationDB
"Inventory Service" --> inventoryDB

' ───────────────────────────────────────────────────────────
' Infrastructure 연결
' ───────────────────────────────────────────────────────────
"User Service" ..> cache : 사용자 캐싱
"Order Service" ..> cache : 주문 캐싱
"Inventory Service" ..> cache : 재고 캐싱

"User Service" ..> "Service Discovery" : 서비스 등록
"Order Service" ..> "Service Discovery" : 서비스 등록
"Payment Service" ..> "Service Discovery" : 서비스 등록
"Notification Service" ..> "Service Discovery" : 서비스 등록
"Inventory Service" ..> "Service Discovery" : 서비스 등록

' ───────────────────────────────────────────────────────────
' 주석
' ───────────────────────────────────────────────────────────
note top of "API Gateway"
  **API Gateway 책임**

  1. 인증/인가 (JWT 검증)
  2. 요청 라우팅
  3. Rate Limiting (DDoS 방어)
  4. 로깅 및 모니터링
  5. CORS 처리

  **기술 스택**: Kong, Nginx, Spring Cloud Gateway
end note

note right of "Order Service"
  **동기 vs 비동기 통신 선택 기준**

  **동기 (REST API)**:
  - 즉시 응답 필요 (재고 확인)
  - 트랜잭션 일관성 중요

  **비동기 (Message Queue)**:
  - 알림 발송 (실패해도 재시도)
  - 이벤트 기반 상태 변경
  - 서비스 간 결합도 최소화

  **패턴**: Saga Pattern, Event Sourcing
end note

note bottom of mq
  **메시지 큐 활용**

  **이벤트 예시**:
  - OrderCreated
  - PaymentCompleted
  - StockChanged
  - UserRegistered

  **장점**:
  - 서비스 디커플링
  - 비동기 처리로 응답 시간 단축
  - 실패 시 재시도 메커니즘

  **주의사항**:
  - 멱등성 보장 (중복 처리 방지)
  - Dead Letter Queue 설정
end note

note bottom of userDB
  **Database per Service 패턴**

  **원칙**:
  - 각 서비스가 독립적인 DB 소유
  - 다른 서비스 DB 직접 접근 금지

  **트레이드오프**:
  - ✅ 서비스 독립성 보장
  - ✅ 기술 스택 자유도 (Polyglot Persistence)
  - ❌ 분산 트랜잭션 복잡도 증가
  - ❌ 조인 쿼리 불가 (API 조합 필요)

  **해결책**: Saga Pattern, CQRS
end note

' ───────────────────────────────────────────────────────────
' 장애 시나리오 표시
' ───────────────────────────────────────────────────────────
note as failureScenario
  **장애 격리 및 복구 전략**

  **Circuit Breaker 적용**:
  - Order Service → Inventory Service 호출 실패 시
  - 3회 연속 실패 → Circuit Open
  - Fallback: 재고 확인 생략 (임시 주문 허용)

  **Retry 정책**:
  - 네트워크 일시 장애: 3회 재시도 (Exponential Backoff)
  - 비즈니스 로직 실패: 재시도 안 함

  **Timeout 설정**:
  - API 호출: 3초 타임아웃
  - DB 쿼리: 5초 타임아웃

  **모니터링**:
  - Prometheus + Grafana
  - Distributed Tracing (Jaeger, Zipkin)
end note

' ───────────────────────────────────────────────────────────
' 범례
' ───────────────────────────────────────────────────────────
legend right
  **통신 패턴**
  | 기호 | 의미 |
  | ──> | 동기 호출 (REST API) |
  | ··> | 비동기 통신 (Message Queue) |

  **컴포넌트 타입**
  | 색상 | 타입 |
  | 가장 밝은 회색 | Gateway |
  | 중간 회색 | Service |
  | 진한 회색 | Infrastructure |
  | 가장 진한 회색 | Database |

  **배포 단위**
  각 Service는 독립 배포 가능 (Kubernetes Pod)
end legend

@enduml
