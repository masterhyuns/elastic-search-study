# Remix 완벽 가이드 - 03. 데이터 로딩과 액션

## 목차
1. [Loader 함수 완벽 가이드](#loader-함수-완벽-가이드)
2. [Action 함수 완벽 가이드](#action-함수-완벽-가이드)
3. [데이터 접근하기 (useLoaderData, useActionData)](#데이터-접근하기)
4. [재검증 (Revalidation)](#재검증-revalidation)
5. [Request와 Response 다루기](#request와-response-다루기)
6. [타입 안정성](#타입-안정성)
7. [고급 패턴](#고급-패턴)

---

## Loader 함수 완벽 가이드

Loader는 컴포넌트가 렌더링되기 전에 서버에서 데이터를 가져오는 함수입니다.

### 1. 기본 사용법

```typescript
// app/routes/posts._index.tsx
import { json, LoaderFunctionArgs } from "@remix-run/node";
import { useLoaderData } from "@remix-run/react";

/**
 * loader: 서버에서만 실행되는 데이터 로딩 함수
 * - GET 요청 시 실행
 * - 컴포넌트 렌더링 전에 실행
 * - 데이터베이스, API 호출 가능
 */
export const loader = async ({ request, params }: LoaderFunctionArgs) => {
  // 데이터베이스에서 포스트 가져오기
  const posts = await db.post.findMany({
    orderBy: { createdAt: "desc" },
    take: 10
  });

  // json() 헬퍼로 JSON 응답 반환
  return json({ posts });
};

export default function PostsIndex() {
  // useLoaderData로 loader에서 반환한 데이터 접근
  const { posts } = useLoaderData<typeof loader>();

  return (
    <div>
      <h1>모든 포스트</h1>
      <ul>
        {posts.map(post => (
          <li key={post.id}>
            <Link to={`/posts/${post.id}`}>{post.title}</Link>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### 2. LoaderFunctionArgs 상세

```typescript
export const loader = async ({
  request,  // Web Request 객체
  params,   // URL 파라미터
  context   // 커스텀 컨텍스트
}: LoaderFunctionArgs) => {
  // 1. URL 파라미터 사용
  const userId = params.userId;

  // 2. URL 쿼리 파라미터 추출
  const url = new URL(request.url);
  const page = url.searchParams.get("page") || "1";
  const search = url.searchParams.get("search") || "";

  // 3. 헤더 읽기
  const userAgent = request.headers.get("User-Agent");

  // 4. 쿠키 읽기
  const cookie = request.headers.get("Cookie");

  return json({ userId, page, search });
};
```

### 3. 다양한 응답 형식

```typescript
// JSON 응답
export const loader = async () => {
  return json({ data: "hello" }, {
    headers: {
      "Cache-Control": "public, max-age=300"
    }
  });
};

// Redirect
export const loader = async ({ request }: LoaderFunctionArgs) => {
  const user = await getUser(request);
  if (!user) {
    return redirect("/login");
  }
  return json({ user });
};

// 404 에러
export const loader = async ({ params }: LoaderFunctionArgs) => {
  const post = await db.post.findUnique({
    where: { id: params.postId }
  });

  if (!post) {
    throw new Response("Post not found", { status: 404 });
  }

  return json({ post });
};

// 커스텀 Response
export const loader = async () => {
  return new Response("Hello World", {
    status: 200,
    headers: {
      "Content-Type": "text/plain"
    }
  });
};
```

### 4. 병렬 데이터 로딩

```typescript
// 중첩 라우트에서 각 loader는 병렬로 실행됩니다!

// app/routes/dashboard.tsx
export const loader = async () => {
  const user = await getUser(); // 1초 소요
  return json({ user });
};

// app/routes/dashboard.analytics.tsx
export const loader = async () => {
  const analytics = await getAnalytics(); // 2초 소요
  return json({ analytics });
};

// 총 소요 시간: 2초 (병렬 실행) vs 3초 (순차 실행)
```

### 5. 데이터 캐싱

```typescript
// 서버 사이드 캐싱
const cache = new Map();

export const loader = async ({ params }: LoaderFunctionArgs) => {
  const cacheKey = `post-${params.postId}`;

  // 캐시 확인
  if (cache.has(cacheKey)) {
    return json(cache.get(cacheKey));
  }

  // 데이터 로드
  const post = await db.post.findUnique({
    where: { id: params.postId }
  });

  // 캐시 저장
  cache.set(cacheKey, { post });

  // 브라우저 캐싱
  return json({ post }, {
    headers: {
      "Cache-Control": "public, max-age=300, s-maxage=3600"
    }
  });
};
```

---

## Action 함수 완벽 가이드

Action은 POST, PUT, DELETE 등의 요청을 처리하는 서버 함수입니다.

### 1. 기본 사용법

```typescript
// app/routes/posts.new.tsx
import { json, redirect, ActionFunctionArgs } from "@remix-run/node";
import { Form, useActionData } from "@remix-run/react";

/**
 * action: 서버에서만 실행되는 데이터 변경 함수
 * - POST, PUT, DELETE 등의 요청 시 실행
 * - 폼 제출 처리
 * - 데이터베이스 쓰기 작업
 */
export const action = async ({ request }: ActionFunctionArgs) => {
  // FormData 파싱
  const formData = await request.formData();
  const title = formData.get("title");
  const content = formData.get("content");

  // 유효성 검증
  const errors: Record<string, string> = {};

  if (!title || title.toString().length < 3) {
    errors.title = "제목은 3글자 이상이어야 합니다";
  }

  if (!content) {
    errors.content = "내용을 입력해주세요";
  }

  // 에러가 있으면 반환
  if (Object.keys(errors).length > 0) {
    return json({ errors }, { status: 400 });
  }

  // 데이터베이스에 저장
  const post = await db.post.create({
    data: {
      title: title.toString(),
      content: content.toString()
    }
  });

  // 성공 시 리다이렉트
  return redirect(`/posts/${post.id}`);
};

export default function NewPost() {
  const actionData = useActionData<typeof action>();

  return (
    <Form method="post">
      <div>
        <label>
          제목:
          <input name="title" type="text" />
          {actionData?.errors?.title && (
            <p style={{ color: "red" }}>{actionData.errors.title}</p>
          )}
        </label>
      </div>

      <div>
        <label>
          내용:
          <textarea name="content" />
          {actionData?.errors?.content && (
            <p style={{ color: "red" }}>{actionData.errors.content}</p>
          )}
        </label>
      </div>

      <button type="submit">작성하기</button>
    </Form>
  );
}
```

### 2. HTTP 메소드별 처리

```typescript
export const action = async ({ request }: ActionFunctionArgs) => {
  const formData = await request.formData();

  // HTTP 메소드에 따라 다른 로직 실행
  switch (request.method) {
    case "POST": {
      // 새로운 데이터 생성
      const title = formData.get("title");
      const post = await db.post.create({
        data: { title: title.toString() }
      });
      return json({ post });
    }

    case "PUT": {
      // 기존 데이터 업데이트
      const id = formData.get("id");
      const title = formData.get("title");
      const post = await db.post.update({
        where: { id: id.toString() },
        data: { title: title.toString() }
      });
      return json({ post });
    }

    case "DELETE": {
      // 데이터 삭제
      const id = formData.get("id");
      await db.post.delete({
        where: { id: id.toString() }
      });
      return redirect("/posts");
    }

    default: {
      throw new Response("Method not allowed", { status: 405 });
    }
  }
};
```

### 3. Intent 패턴 (하나의 action에서 여러 작업)

```typescript
export const action = async ({ request }: ActionFunctionArgs) => {
  const formData = await request.formData();
  const intent = formData.get("intent");

  switch (intent) {
    case "create": {
      const title = formData.get("title");
      const post = await db.post.create({
        data: { title: title.toString() }
      });
      return json({ post });
    }

    case "update": {
      const id = formData.get("id");
      const title = formData.get("title");
      const post = await db.post.update({
        where: { id: id.toString() },
        data: { title: title.toString() }
      });
      return json({ post });
    }

    case "delete": {
      const id = formData.get("id");
      await db.post.delete({
        where: { id: id.toString() }
      });
      return json({ success: true });
    }

    default: {
      throw new Error(`Unknown intent: ${intent}`);
    }
  }
};

// 사용 예시
<Form method="post">
  <input name="title" />
  <button name="intent" value="create">생성</button>
  <button name="intent" value="update">수정</button>
  <button name="intent" value="delete">삭제</button>
</Form>
```

### 4. 파일 업로드 처리

```typescript
// app/routes/upload.tsx
export const action = async ({ request }: ActionFunctionArgs) => {
  const formData = await request.formData();
  const file = formData.get("file") as File;

  if (!file) {
    return json({ error: "파일을 선택해주세요" }, { status: 400 });
  }

  // 파일 크기 검증
  const maxSize = 5 * 1024 * 1024; // 5MB
  if (file.size > maxSize) {
    return json({ error: "파일 크기는 5MB 이하여야 합니다" }, { status: 400 });
  }

  // 파일 타입 검증
  const allowedTypes = ["image/jpeg", "image/png", "image/gif"];
  if (!allowedTypes.includes(file.type)) {
    return json({ error: "이미지 파일만 업로드 가능합니다" }, { status: 400 });
  }

  // 파일을 ArrayBuffer로 변환
  const arrayBuffer = await file.arrayBuffer();
  const buffer = Buffer.from(arrayBuffer);

  // 파일 저장 (예: S3, 로컬 파일 시스템)
  const fileName = `${Date.now()}-${file.name}`;
  await uploadToS3(buffer, fileName);

  return json({ fileName, url: `/uploads/${fileName}` });
};

export default function Upload() {
  const actionData = useActionData<typeof action>();

  return (
    <Form method="post" encType="multipart/form-data">
      <input type="file" name="file" accept="image/*" />
      <button type="submit">업로드</button>

      {actionData?.error && (
        <p style={{ color: "red" }}>{actionData.error}</p>
      )}

      {actionData?.url && (
        <img src={actionData.url} alt="Uploaded" />
      )}
    </Form>
  );
}
```

---

## 데이터 접근하기

### 1. useLoaderData

```typescript
import { useLoaderData } from "@remix-run/react";

export const loader = async () => {
  return json({ message: "Hello from loader" });
};

export default function MyRoute() {
  // 타입 안전하게 loader 데이터 접근
  const data = useLoaderData<typeof loader>();

  return <div>{data.message}</div>;
}
```

### 2. useActionData

```typescript
import { useActionData } from "@remix-run/react";

export const action = async ({ request }: ActionFunctionArgs) => {
  const formData = await request.formData();
  const email = formData.get("email");

  if (!email) {
    return json({ error: "이메일을 입력해주세요" });
  }

  return json({ success: true, email });
};

export default function Subscribe() {
  const actionData = useActionData<typeof action>();

  return (
    <Form method="post">
      <input name="email" type="email" />
      <button type="submit">구독</button>

      {actionData?.error && (
        <p style={{ color: "red" }}>{actionData.error}</p>
      )}

      {actionData?.success && (
        <p style={{ color: "green" }}>
          {actionData.email}로 구독 완료!
        </p>
      )}
    </Form>
  );
}
```

### 3. useRouteLoaderData (부모 라우트 데이터 접근)

```typescript
// app/routes/dashboard.tsx
export const loader = async () => {
  return json({ user: await getUser() });
};

// app/routes/dashboard.settings.tsx
import { useRouteLoaderData } from "@remix-run/react";

export default function Settings() {
  // 부모 라우트의 loader 데이터 접근
  const parentData = useRouteLoaderData("routes/dashboard");

  return <div>사용자: {parentData?.user.name}</div>;
}
```

### 4. useFetcher (다른 라우트의 loader/action 호출)

```typescript
import { useFetcher } from "@remix-run/react";

export default function Newsletter() {
  const fetcher = useFetcher();

  return (
    <fetcher.Form method="post" action="/api/subscribe">
      <input name="email" type="email" />
      <button type="submit">
        {fetcher.state === "submitting" ? "제출 중..." : "구독"}
      </button>

      {fetcher.data?.success && <p>구독 완료!</p>}
    </fetcher.Form>
  );
}
```

---

## 재검증 (Revalidation)

Remix는 데이터 변경 후 자동으로 관련 loader를 다시 실행합니다.

### 1. 자동 재검증

```typescript
// 폼 제출 후 자동으로 페이지의 모든 loader가 재실행됨
<Form method="post">
  <input name="title" />
  <button type="submit">작성</button>
</Form>
```

### 2. useRevalidator (수동 재검증)

```typescript
import { useRevalidator } from "@remix-run/react";

export default function Dashboard() {
  const revalidator = useRevalidator();

  const handleRefresh = () => {
    // 현재 페이지의 모든 loader 재실행
    revalidator.revalidate();
  };

  return (
    <div>
      <button onClick={handleRefresh}>
        {revalidator.state === "loading" ? "새로고침 중..." : "새로고침"}
      </button>
    </div>
  );
}
```

### 3. shouldRevalidate (재검증 제어)

```typescript
// 특정 조건에서만 재검증
export const shouldRevalidate = ({
  currentUrl,
  nextUrl,
  formMethod,
  defaultShouldRevalidate
}: ShouldRevalidateFunctionArgs) => {
  // POST 요청 시에만 재검증
  if (formMethod === "POST") {
    return true;
  }

  // URL이 변경되지 않았으면 재검증 안 함
  if (currentUrl.pathname === nextUrl.pathname) {
    return false;
  }

  return defaultShouldRevalidate;
};
```

---

## Request와 Response 다루기

### 1. Request 객체

```typescript
export const loader = async ({ request }: LoaderFunctionArgs) => {
  // URL 정보
  const url = new URL(request.url);
  console.log(url.pathname);     // "/posts"
  console.log(url.search);       // "?page=1"
  console.log(url.searchParams.get("page")); // "1"

  // HTTP 메소드
  console.log(request.method);   // "GET"

  // 헤더
  const userAgent = request.headers.get("User-Agent");
  const cookie = request.headers.get("Cookie");

  // Body (POST 요청)
  if (request.method === "POST") {
    const formData = await request.formData();
    const json = await request.json();
    const text = await request.text();
  }

  return json({});
};
```

### 2. Response 객체

```typescript
// JSON 응답
export const loader = () => {
  return json({ data: "hello" }, {
    status: 200,
    headers: {
      "Cache-Control": "public, max-age=300",
      "X-Custom-Header": "value"
    }
  });
};

// Redirect 응답
export const action = async () => {
  return redirect("/success", {
    headers: {
      "Set-Cookie": "session=abc123"
    }
  });
};

// 커스텀 응답
export const loader = () => {
  return new Response("Hello World", {
    status: 200,
    headers: {
      "Content-Type": "text/plain"
    }
  });
};

// 스트리밍 응답
export const loader = () => {
  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue("Hello ");
      setTimeout(() => {
        controller.enqueue("World");
        controller.close();
      }, 1000);
    }
  });

  return new Response(stream, {
    headers: { "Content-Type": "text/plain" }
  });
};
```

---

## 타입 안정성

### 1. 타입 추론

```typescript
// loader의 반환 타입이 자동으로 추론됨
export const loader = async () => {
  return json({
    user: { id: "1", name: "John" },
    posts: [{ id: "1", title: "Hello" }]
  });
};

export default function MyRoute() {
  // 타입 안전하게 접근
  const data = useLoaderData<typeof loader>();
  //    ^? { user: { id: string, name: string }, posts: { id: string, title: string }[] }

  return <div>{data.user.name}</div>;
}
```

### 2. Zod를 사용한 유효성 검증

```typescript
import { z } from "zod";

const PostSchema = z.object({
  title: z.string().min(3, "제목은 3글자 이상이어야 합니다"),
  content: z.string().min(10, "내용은 10글자 이상이어야 합니다"),
  published: z.boolean().optional()
});

export const action = async ({ request }: ActionFunctionArgs) => {
  const formData = await request.formData();

  // FormData를 객체로 변환
  const data = {
    title: formData.get("title"),
    content: formData.get("content"),
    published: formData.get("published") === "on"
  };

  // Zod로 유효성 검증
  const result = PostSchema.safeParse(data);

  if (!result.success) {
    return json({
      errors: result.error.flatten().fieldErrors
    }, { status: 400 });
  }

  // 타입 안전한 데이터
  const validData = result.data;
  //    ^? { title: string, content: string, published?: boolean }

  const post = await db.post.create({ data: validData });

  return redirect(`/posts/${post.id}`);
};
```

---

## 고급 패턴

### 1. 낙관적 UI (Optimistic UI)

```typescript
import { useFetcher } from "@remix-run/react";

export default function TodoItem({ todo }) {
  const fetcher = useFetcher();

  // 낙관적 상태 계산
  const isCompleted = fetcher.formData
    ? fetcher.formData.get("completed") === "true"
    : todo.completed;

  return (
    <fetcher.Form method="post" action={`/todos/${todo.id}`}>
      <input
        type="checkbox"
        name="completed"
        value="true"
        checked={isCompleted}
        onChange={(e) => {
          fetcher.submit(e.currentTarget.form);
        }}
      />
      <span style={{ textDecoration: isCompleted ? "line-through" : "none" }}>
        {todo.title}
      </span>
    </fetcher.Form>
  );
}
```

### 2. 무한 스크롤

```typescript
import { useLoaderData, useFetcher } from "@remix-run/react";
import { useEffect } from "react";

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const url = new URL(request.url);
  const page = parseInt(url.searchParams.get("page") || "1");
  const limit = 20;

  const posts = await db.post.findMany({
    skip: (page - 1) * limit,
    take: limit
  });

  const hasMore = posts.length === limit;

  return json({ posts, page, hasMore });
};

export default function Posts() {
  const { posts: initialPosts, page: initialPage, hasMore: initialHasMore } = useLoaderData<typeof loader>();
  const fetcher = useFetcher<typeof loader>();

  const posts = fetcher.data?.posts
    ? [...initialPosts, ...fetcher.data.posts]
    : initialPosts;

  const hasMore = fetcher.data?.hasMore ?? initialHasMore;
  const page = fetcher.data?.page ?? initialPage;

  useEffect(() => {
    const observer = new IntersectionObserver((entries) => {
      if (entries[0].isIntersecting && hasMore && fetcher.state === "idle") {
        fetcher.load(`?page=${page + 1}`);
      }
    });

    const sentinel = document.getElementById("sentinel");
    if (sentinel) observer.observe(sentinel);

    return () => observer.disconnect();
  }, [hasMore, page, fetcher]);

  return (
    <div>
      {posts.map(post => (
        <div key={post.id}>{post.title}</div>
      ))}
      {hasMore && <div id="sentinel">로딩 중...</div>}
    </div>
  );
}
```

### 3. 멀티스텝 폼

```typescript
import { useState } from "react";
import { Form, useActionData } from "@remix-run/react";

export const action = async ({ request }: ActionFunctionArgs) => {
  const formData = await request.formData();
  const step = formData.get("step");

  if (step === "3") {
    // 최종 제출
    const user = {
      name: formData.get("name"),
      email: formData.get("email"),
      phone: formData.get("phone"),
      address: formData.get("address")
    };

    await db.user.create({ data: user });

    return redirect("/success");
  }

  return json({ success: true });
};

export default function MultiStepForm() {
  const [step, setStep] = useState(1);
  const [formData, setFormData] = useState({});

  const handleNext = (data: Record<string, string>) => {
    setFormData({ ...formData, ...data });
    setStep(step + 1);
  };

  return (
    <div>
      {step === 1 && (
        <Form onSubmit={(e) => {
          e.preventDefault();
          const data = new FormData(e.currentTarget);
          handleNext({
            name: data.get("name") as string,
            email: data.get("email") as string
          });
        }}>
          <input name="name" placeholder="이름" required />
          <input name="email" type="email" placeholder="이메일" required />
          <button type="submit">다음</button>
        </Form>
      )}

      {step === 2 && (
        <Form onSubmit={(e) => {
          e.preventDefault();
          const data = new FormData(e.currentTarget);
          handleNext({
            phone: data.get("phone") as string,
            address: data.get("address") as string
          });
        }}>
          <input name="phone" placeholder="전화번호" required />
          <input name="address" placeholder="주소" required />
          <button type="button" onClick={() => setStep(1)}>이전</button>
          <button type="submit">다음</button>
        </Form>
      )}

      {step === 3 && (
        <Form method="post">
          <input type="hidden" name="step" value="3" />
          {Object.entries(formData).map(([key, value]) => (
            <input key={key} type="hidden" name={key} value={value as string} />
          ))}
          <h2>확인</h2>
          <pre>{JSON.stringify(formData, null, 2)}</pre>
          <button type="button" onClick={() => setStep(2)}>이전</button>
          <button type="submit">제출</button>
        </Form>
      )}
    </div>
  );
}
```

---

## 다음 단계

다음 문서에서는 Remix의 Form과 사용자 상호작용을 상세히 알아보겠습니다:
- Form 컴포넌트 깊이 파기
- 폼 상태 관리
- useFetcher 고급 사용법
- 파일 업로드 최적화

**계속 학습하기**: [04-Form과-사용자-상호작용.md](./04-Form과-사용자-상호작용.md)
