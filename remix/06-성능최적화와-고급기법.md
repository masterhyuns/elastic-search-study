# Remix 완벽 가이드 - 06. 성능 최적화와 고급 기법

## 목차
1. [캐싱 전략](#캐싱-전략)
2. [Prefetching](#prefetching)
3. [리소스 라우트](#리소스-라우트)
4. [스트리밍과 Deferred Data](#스트리밍과-deferred-data)
5. [이미지 최적화](#이미지-최적화)
6. [번들 사이즈 최적화](#번들-사이즈-최적화)
7. [성능 측정](#성능-측정)

---

## 캐싱 전략

Remix는 HTTP 캐싱을 활용하여 성능을 최적화합니다.

### 1. Browser 캐싱

```typescript
// app/routes/posts._index.tsx
export const headers = () => {
  return {
    // 브라우저 캐시: 5분
    // CDN 캐시: 1시간
    "Cache-Control": "public, max-age=300, s-maxage=3600"
  };
};

export const loader = async () => {
  const posts = await db.post.findMany();
  return json({ posts });
};
```

**캐시 지시자 설명:**
- `public`: 브라우저와 CDN 모두 캐싱 가능
- `private`: 브라우저만 캐싱 가능 (개인정보 포함 시)
- `max-age=300`: 브라우저 캐시 유효 시간 (초)
- `s-maxage=3600`: CDN/프록시 캐시 유효 시간 (초)
- `no-cache`: 캐시 사용 전 서버에 재검증 요청
- `no-store`: 캐싱 금지

### 2. 동적 캐싱

```typescript
export const headers = ({ loaderHeaders, parentHeaders }: {
  loaderHeaders: Headers;
  parentHeaders: Headers;
}) => {
  return {
    "Cache-Control": loaderHeaders.get("Cache-Control") || "no-cache"
  };
};

export const loader = async ({ params }: LoaderFunctionArgs) => {
  const post = await db.post.findUnique({
    where: { id: params.postId }
  });

  // 발행된 포스트는 캐싱, 드래프트는 캐싱 안 함
  const cacheControl = post.published
    ? "public, max-age=3600"
    : "private, no-cache";

  return json(
    { post },
    {
      headers: {
        "Cache-Control": cacheControl
      }
    }
  );
};
```

### 3. ETag를 사용한 조건부 캐싱

```typescript
import { createHash } from "crypto";

export const loader = async ({ request, params }: LoaderFunctionArgs) => {
  const post = await db.post.findUnique({
    where: { id: params.postId }
  });

  // 데이터의 해시값 생성
  const etag = createHash("md5")
    .update(JSON.stringify(post))
    .digest("hex");

  // 클라이언트가 보낸 ETag 확인
  const ifNoneMatch = request.headers.get("If-None-Match");

  if (ifNoneMatch === etag) {
    // 데이터가 변경되지 않음
    return new Response(null, {
      status: 304,
      headers: {
        "ETag": etag,
        "Cache-Control": "public, max-age=300"
      }
    });
  }

  // 데이터 반환
  return json(
    { post },
    {
      headers: {
        "ETag": etag,
        "Cache-Control": "public, max-age=300"
      }
    }
  );
};
```

### 4. 서버 사이드 메모리 캐싱

```typescript
// app/utils/cache.server.ts
import { LRUCache } from "lru-cache";

const cache = new LRUCache<string, any>({
  max: 500, // 최대 항목 수
  ttl: 1000 * 60 * 5, // 5분
  updateAgeOnGet: true
});

export const getCached = async <T>(
  key: string,
  fetcher: () => Promise<T>
): Promise<T> => {
  const cached = cache.get(key);
  if (cached) return cached;

  const data = await fetcher();
  cache.set(key, data);
  return data;
};

// 사용 예시
export const loader = async ({ params }: LoaderFunctionArgs) => {
  const post = await getCached(
    `post-${params.postId}`,
    () => db.post.findUnique({ where: { id: params.postId } })
  );

  return json({ post });
};
```

---

## Prefetching

사용자가 링크를 클릭하기 전에 미리 데이터를 로드하여 체감 속도를 향상시킵니다.

### 1. Link Prefetch

```typescript
import { Link } from "@remix-run/react";

export default function PostsList({ posts }) {
  return (
    <ul>
      {posts.map(post => (
        <li key={post.id}>
          {/* 마우스 오버 시 prefetch */}
          <Link
            to={`/posts/${post.id}`}
            prefetch="intent"
          >
            {post.title}
          </Link>
        </li>
      ))}
    </ul>
  );
}
```

**prefetch 옵션:**
- `"none"` (기본값): Prefetch 안 함
- `"intent"`: 마우스 오버나 포커스 시 prefetch
- `"render"`: 링크가 렌더링될 때 즉시 prefetch
- `"viewport"`: 뷰포트에 보일 때 prefetch

### 2. 조건부 Prefetch

```typescript
export default function PostsList({ posts }) {
  return (
    <ul>
      {posts.map((post, index) => (
        <li key={post.id}>
          <Link
            to={`/posts/${post.id}`}
            // 상위 5개만 prefetch
            prefetch={index < 5 ? "intent" : "none"}
          >
            {post.title}
          </Link>
        </li>
      ))}
    </ul>
  );
}
```

### 3. PrefetchPageLinks (전체 페이지 prefetch)

```typescript
import { PrefetchPageLinks } from "@remix-run/react";

export default function PostPreview({ post }) {
  const [isHovering, setIsHovering] = useState(false);

  return (
    <div
      onMouseEnter={() => setIsHovering(true)}
      onMouseLeave={() => setIsHovering(false)}
    >
      {/* 마우스 오버 시 페이지의 모든 리소스 prefetch */}
      {isHovering && <PrefetchPageLinks page={`/posts/${post.id}`} />}

      <h3>{post.title}</h3>
      <p>{post.excerpt}</p>
      <Link to={`/posts/${post.id}`}>더 보기</Link>
    </div>
  );
}
```

---

## 리소스 라우트

HTML이 아닌 다른 형식의 데이터를 반환하는 라우트입니다.

### 1. API 엔드포인트

```typescript
// app/routes/api.posts.tsx
export const loader = async ({ request }: LoaderFunctionArgs) => {
  const url = new URL(request.url);
  const page = parseInt(url.searchParams.get("page") || "1");
  const limit = parseInt(url.searchParams.get("limit") || "10");

  const posts = await db.post.findMany({
    skip: (page - 1) * limit,
    take: limit
  });

  // JSON API 응답
  return json({
    data: posts,
    meta: {
      page,
      limit,
      total: await db.post.count()
    }
  });
};
```

### 2. CSV 다운로드

```typescript
// app/routes/export.users.csv.tsx
export const loader = async () => {
  const users = await db.user.findMany();

  // CSV 생성
  const csv = [
    "ID,Name,Email,Created At",
    ...users.map(u => `${u.id},${u.name},${u.email},${u.createdAt}`)
  ].join("\n");

  return new Response(csv, {
    headers: {
      "Content-Type": "text/csv",
      "Content-Disposition": "attachment; filename=users.csv"
    }
  });
};
```

### 3. PDF 생성

```typescript
// app/routes/invoice.$id.pdf.tsx
import { jsPDF } from "jspdf";

export const loader = async ({ params }: LoaderFunctionArgs) => {
  const invoice = await db.invoice.findUnique({
    where: { id: params.id },
    include: { items: true }
  });

  // PDF 생성
  const doc = new jsPDF();
  doc.text(`Invoice #${invoice.number}`, 10, 10);
  doc.text(`Total: $${invoice.total}`, 10, 20);
  // ... 더 많은 내용 추가

  const pdfBuffer = doc.output("arraybuffer");

  return new Response(pdfBuffer, {
    headers: {
      "Content-Type": "application/pdf",
      "Content-Disposition": `attachment; filename=invoice-${invoice.number}.pdf`
    }
  });
};
```

### 4. 이미지 리사이징

```typescript
// app/routes/images.resize.tsx
import sharp from "sharp";

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const url = new URL(request.url);
  const imageUrl = url.searchParams.get("url");
  const width = parseInt(url.searchParams.get("width") || "800");
  const height = parseInt(url.searchParams.get("height") || "600");

  // 원본 이미지 가져오기
  const response = await fetch(imageUrl!);
  const buffer = Buffer.from(await response.arrayBuffer());

  // 리사이징
  const resized = await sharp(buffer)
    .resize(width, height, { fit: "cover" })
    .webp({ quality: 80 })
    .toBuffer();

  return new Response(resized, {
    headers: {
      "Content-Type": "image/webp",
      "Cache-Control": "public, max-age=31536000, immutable"
    }
  });
};
```

---

## 스트리밍과 Deferred Data

긴 작업을 백그라운드에서 처리하면서 빠르게 페이지를 렌더링합니다.

### 1. defer 기본 사용법

```typescript
// app/routes/dashboard.tsx
import { defer } from "@remix-run/node";
import { Await, useLoaderData } from "@remix-run/react";
import { Suspense } from "react";

export const loader = async () => {
  // 빠른 데이터 (즉시 로드)
  const user = await getUser();

  // 느린 데이터 (백그라운드에서 로드)
  const analyticsPromise = getAnalytics(); // await 없음!

  return defer({
    user,
    analytics: analyticsPromise // Promise 전달
  });
};

export default function Dashboard() {
  const { user, analytics } = useLoaderData<typeof loader>();

  return (
    <div>
      {/* 즉시 렌더링 */}
      <h1>안녕하세요, {user.name}님!</h1>

      {/* 로딩 중 fallback 표시 */}
      <Suspense fallback={<div>분석 데이터 로딩 중...</div>}>
        <Await resolve={analytics}>
          {(data) => (
            <div>
              <h2>이번 달 통계</h2>
              <p>방문자: {data.visitors}</p>
              <p>페이지뷰: {data.pageViews}</p>
            </div>
          )}
        </Await>
      </Suspense>
    </div>
  );
}
```

### 2. 에러 처리

```typescript
export default function Dashboard() {
  const { user, analytics } = useLoaderData<typeof loader>();

  return (
    <div>
      <h1>안녕하세요, {user.name}님!</h1>

      <Suspense fallback={<LoadingSpinner />}>
        <Await
          resolve={analytics}
          errorElement={
            <div className="error">
              분석 데이터를 불러올 수 없습니다.
            </div>
          }
        >
          {(data) => <AnalyticsChart data={data} />}
        </Await>
      </Suspense>
    </div>
  );
}
```

### 3. 여러 deferred 데이터

```typescript
export const loader = async () => {
  return defer({
    user: await getUser(), // 즉시
    posts: getRecentPosts(), // 지연
    comments: getRecentComments(), // 지연
    analytics: getAnalytics() // 지연
  });
};

export default function Dashboard() {
  const data = useLoaderData<typeof loader>();

  return (
    <div>
      <UserProfile user={data.user} />

      <Suspense fallback={<Skeleton />}>
        <Await resolve={data.posts}>
          {(posts) => <PostsList posts={posts} />}
        </Await>
      </Suspense>

      <Suspense fallback={<Skeleton />}>
        <Await resolve={data.comments}>
          {(comments) => <CommentsList comments={comments} />}
        </Await>
      </Suspense>

      <Suspense fallback={<Skeleton />}>
        <Await resolve={data.analytics}>
          {(analytics) => <AnalyticsChart data={analytics} />}
        </Await>
      </Suspense>
    </div>
  );
}
```

---

## 이미지 최적화

### 1. 반응형 이미지

```typescript
export default function ResponsiveImage({ src, alt }) {
  return (
    <picture>
      {/* WebP 형식 (현대 브라우저) */}
      <source
        srcSet={`
          ${src}?w=400&format=webp 400w,
          ${src}?w=800&format=webp 800w,
          ${src}?w=1200&format=webp 1200w
        `}
        sizes="(max-width: 640px) 400px, (max-width: 1024px) 800px, 1200px"
        type="image/webp"
      />

      {/* JPEG 폴백 */}
      <source
        srcSet={`
          ${src}?w=400 400w,
          ${src}?w=800 800w,
          ${src}?w=1200 1200w
        `}
        sizes="(max-width: 640px) 400px, (max-width: 1024px) 800px, 1200px"
        type="image/jpeg"
      />

      <img
        src={`${src}?w=800`}
        alt={alt}
        loading="lazy"
      />
    </picture>
  );
}
```

### 2. Lazy Loading

```typescript
import { useEffect, useRef, useState } from "react";

const LazyImage = ({ src, alt, placeholder }) => {
  const [isLoaded, setIsLoaded] = useState(false);
  const [isInView, setIsInView] = useState(false);
  const imgRef = useRef<HTMLImageElement>(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsInView(true);
          observer.disconnect();
        }
      },
      { rootMargin: "100px" } // 100px 전에 미리 로드
    );

    if (imgRef.current) {
      observer.observe(imgRef.current);
    }

    return () => observer.disconnect();
  }, []);

  return (
    <div className="lazy-image-wrapper">
      <img
        ref={imgRef}
        src={isInView ? src : placeholder}
        alt={alt}
        onLoad={() => setIsLoaded(true)}
        style={{
          opacity: isLoaded ? 1 : 0,
          transition: "opacity 0.3s"
        }}
      />
    </div>
  );
};
```

### 3. Blurhash Placeholder

```typescript
import { Blurhash } from "react-blurhash";
import { useState } from "react";

const ImageWithBlurhash = ({ src, blurhash, alt }) => {
  const [isLoaded, setIsLoaded] = useState(false);

  return (
    <div style={{ position: "relative" }}>
      {!isLoaded && (
        <Blurhash
          hash={blurhash}
          width="100%"
          height="100%"
          resolutionX={32}
          resolutionY={32}
        />
      )}

      <img
        src={src}
        alt={alt}
        onLoad={() => setIsLoaded(true)}
        style={{
          opacity: isLoaded ? 1 : 0,
          transition: "opacity 0.3s"
        }}
      />
    </div>
  );
};

// 사용 예시
<ImageWithBlurhash
  src="/images/photo.jpg"
  blurhash="LKO2?U%2Tw=w]~RBVZRi};RPxuwH"
  alt="Photo"
/>
```

---

## 번들 사이즈 최적화

### 1. 동적 import

```typescript
import { lazy, Suspense } from "react";

// 큰 컴포넌트는 동적으로 로드
const Chart = lazy(() => import("~/components/Chart"));
const VideoPlayer = lazy(() => import("~/components/VideoPlayer"));

export default function Dashboard() {
  return (
    <div>
      <h1>대시보드</h1>

      <Suspense fallback={<div>차트 로딩 중...</div>}>
        <Chart data={chartData} />
      </Suspense>

      <Suspense fallback={<div>플레이어 로딩 중...</div>}>
        <VideoPlayer url="/video.mp4" />
      </Suspense>
    </div>
  );
}
```

### 2. Tree Shaking

```typescript
// ❌ 나쁜 예: 전체 라이브러리 import
import _ from "lodash";

// ✅ 좋은 예: 필요한 함수만 import
import { debounce, throttle } from "lodash-es";

// 또는
import debounce from "lodash-es/debounce";
import throttle from "lodash-es/throttle";
```

### 3. 번들 분석

```bash
# remix.config.js에 bundle 분석 추가
pnpm add -D @remix-run/dev

# package.json에 스크립트 추가
{
  "scripts": {
    "build": "remix build",
    "build:analyze": "remix build --sourcemap"
  }
}
```

```javascript
// remix.config.js
module.exports = {
  future: {
    v3_fetcherPersist: true,
  },
  // 번들 크기 확인
  serverModuleFormat: "esm",
};
```

---

## 성능 측정

### 1. Web Vitals 측정

```typescript
// app/root.tsx
import { useEffect } from "react";
import { getCLS, getFID, getFCP, getLCP, getTTFB } from "web-vitals";

export default function Root() {
  useEffect(() => {
    // Core Web Vitals 측정
    getCLS(console.log); // Cumulative Layout Shift
    getFID(console.log); // First Input Delay
    getFCP(console.log); // First Contentful Paint
    getLCP(console.log); // Largest Contentful Paint
    getTTFB(console.log); // Time to First Byte
  }, []);

  return (
    <html>
      <body>
        <Outlet />
      </body>
    </html>
  );
}
```

### 2. 커스텀 성능 메트릭

```typescript
// app/utils/performance.ts
export const measurePerformance = (name: string, fn: () => void) => {
  const start = performance.now();
  fn();
  const end = performance.now();

  console.log(`${name}: ${end - start}ms`);

  // Analytics로 전송
  if (typeof window !== "undefined" && window.gtag) {
    window.gtag("event", "timing_complete", {
      name: name,
      value: Math.round(end - start),
      event_category: "Performance"
    });
  }
};

// 사용 예시
export const loader = async () => {
  const start = performance.now();

  const data = await fetchData();

  const duration = performance.now() - start;
  console.log(`Loader duration: ${duration}ms`);

  return json({ data }, {
    headers: {
      "Server-Timing": `loader;dur=${duration}`
    }
  });
};
```

### 3. React DevTools Profiler

```typescript
import { Profiler } from "react";

const onRenderCallback = (
  id: string,
  phase: "mount" | "update",
  actualDuration: number
) => {
  console.log(`${id} (${phase}): ${actualDuration}ms`);
};

export default function App() {
  return (
    <Profiler id="App" onRender={onRenderCallback}>
      <YourComponent />
    </Profiler>
  );
}
```

---

## 다음 단계

다음 문서에서는 실전 예제 프로젝트를 통해 Remix의 모든 기능을 종합적으로 활용하는 방법을 알아보겠습니다:
- Todo 앱
- 블로그 플랫폼
- 전자상거래 사이트
- 대시보드 애플리케이션

**계속 학습하기**: [07-실전-예제-프로젝트.md](./07-실전-예제-프로젝트.md)
