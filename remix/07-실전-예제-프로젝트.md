# Remix 완벽 가이드 - 07. 실전 예제 프로젝트

## 목차
1. [프로젝트 1: Todo 애플리케이션](#프로젝트-1-todo-애플리케이션)
2. [프로젝트 2: 블로그 플랫폼](#프로젝트-2-블로그-플랫폼)
3. [프로젝트 3: 인증 시스템](#프로젝트-3-인증-시스템)
4. [프로젝트 4: 전자상거래 장바구니](#프로젝트-4-전자상거래-장바구니)
5. [배포 가이드](#배포-가이드)
6. [Best Practices 요약](#best-practices-요약)

---

## 프로젝트 1: Todo 애플리케이션

완전한 CRUD 기능을 갖춘 Todo 앱을 구축합니다.

### 1. 데이터베이스 스키마

```prisma
// prisma/schema.prisma
model Todo {
  id        String   @id @default(cuid())
  title     String
  completed Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

### 2. Todos 목록 페이지

```typescript
// app/routes/todos._index.tsx
import { json, ActionFunctionArgs, LoaderFunctionArgs } from "@remix-run/node";
import { Form, useLoaderData, useFetcher } from "@remix-run/react";
import { db } from "~/utils/db.server";

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const url = new URL(request.url);
  const filter = url.searchParams.get("filter") || "all";

  const where = filter === "completed"
    ? { completed: true }
    : filter === "active"
    ? { completed: false }
    : {};

  const todos = await db.todo.findMany({
    where,
    orderBy: { createdAt: "desc" }
  });

  const stats = {
    total: await db.todo.count(),
    completed: await db.todo.count({ where: { completed: true } }),
    active: await db.todo.count({ where: { completed: false } })
  };

  return json({ todos, stats, filter });
};

export const action = async ({ request }: ActionFunctionArgs) => {
  const formData = await request.formData();
  const intent = formData.get("intent");

  switch (intent) {
    case "create": {
      const title = formData.get("title")?.toString();
      if (!title) {
        return json({ error: "제목을 입력해주세요" }, { status: 400 });
      }

      await db.todo.create({
        data: { title }
      });

      return json({ success: true });
    }

    case "toggle": {
      const id = formData.get("id")?.toString();
      const completed = formData.get("completed") === "true";

      await db.todo.update({
        where: { id },
        data: { completed }
      });

      return json({ success: true });
    }

    case "delete": {
      const id = formData.get("id")?.toString();

      await db.todo.delete({
        where: { id }
      });

      return json({ success: true });
    }

    case "clear-completed": {
      await db.todo.deleteMany({
        where: { completed: true }
      });

      return json({ success: true });
    }

    default:
      return json({ error: "Invalid intent" }, { status: 400 });
  }
};

export default function TodosIndex() {
  const { todos, stats, filter } = useLoaderData<typeof loader>();

  return (
    <div className="todo-app">
      <h1>Todo App</h1>

      {/* 새 Todo 추가 */}
      <Form method="post" className="add-todo">
        <input type="hidden" name="intent" value="create" />
        <input
          name="title"
          type="text"
          placeholder="할 일을 입력하세요..."
          autoFocus
        />
        <button type="submit">추가</button>
      </Form>

      {/* 필터 */}
      <div className="filters">
        <Form method="get">
          <button name="filter" value="all" className={filter === "all" ? "active" : ""}>
            전체 ({stats.total})
          </button>
          <button name="filter" value="active" className={filter === "active" ? "active" : ""}>
            진행 중 ({stats.active})
          </button>
          <button name="filter" value="completed" className={filter === "completed" ? "active" : ""}>
            완료 ({stats.completed})
          </button>
        </Form>
      </div>

      {/* Todo 목록 */}
      <ul className="todo-list">
        {todos.map(todo => (
          <TodoItem key={todo.id} todo={todo} />
        ))}
      </ul>

      {/* 완료된 항목 삭제 */}
      {stats.completed > 0 && (
        <Form method="post">
          <input type="hidden" name="intent" value="clear-completed" />
          <button type="submit" className="clear-completed">
            완료된 항목 삭제
          </button>
        </Form>
      )}
    </div>
  );
}

// Todo 아이템 컴포넌트
const TodoItem = ({ todo }) => {
  const fetcher = useFetcher();

  // 낙관적 UI
  const isCompleted = fetcher.formData
    ? fetcher.formData.get("completed") === "true"
    : todo.completed;

  const isDeleting =
    fetcher.state === "submitting" &&
    fetcher.formData?.get("intent") === "delete";

  if (isDeleting) {
    return null; // 삭제 중이면 숨김
  }

  return (
    <li className={isCompleted ? "completed" : ""}>
      <fetcher.Form method="post">
        <input type="hidden" name="intent" value="toggle" />
        <input type="hidden" name="id" value={todo.id} />
        <input type="hidden" name="completed" value={(!isCompleted).toString()} />

        <button type="submit" className="checkbox">
          {isCompleted ? "✓" : "○"}
        </button>
      </fetcher.Form>

      <span className="title">{todo.title}</span>

      <fetcher.Form method="post">
        <input type="hidden" name="intent" value="delete" />
        <input type="hidden" name="id" value={todo.id} />
        <button type="submit" className="delete">
          ✕
        </button>
      </fetcher.Form>
    </li>
  );
};
```

---

## 프로젝트 2: 블로그 플랫폼

MDX를 사용한 블로그 시스템입니다.

### 1. 블로그 포스트 목록

```typescript
// app/routes/blog._index.tsx
import { json, LoaderFunctionArgs } from "@remix-run/node";
import { useLoaderData, Link, Form } from "@remix-run/react";
import { db } from "~/utils/db.server";

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const url = new URL(request.url);
  const search = url.searchParams.get("search") || "";
  const category = url.searchParams.get("category") || "";

  const where = {
    published: true,
    ...(search && {
      OR: [
        { title: { contains: search, mode: "insensitive" } },
        { excerpt: { contains: search, mode: "insensitive" } }
      ]
    }),
    ...(category && { category })
  };

  const [posts, categories] = await Promise.all([
    db.post.findMany({
      where,
      include: {
        author: {
          select: { name: true, avatar: true }
        },
        _count: {
          select: { comments: true }
        }
      },
      orderBy: { publishedAt: "desc" }
    }),
    db.post.findMany({
      where: { published: true },
      select: { category: true },
      distinct: ["category"]
    })
  ]);

  return json({
    posts,
    categories: categories.map(p => p.category),
    search,
    category
  });
};

export const meta: MetaFunction = () => {
  return [
    { title: "블로그 - 기술 아티클" },
    { name: "description", content: "최신 기술 트렌드와 튜토리얼" }
  ];
};

export default function BlogIndex() {
  const { posts, categories, search, category } = useLoaderData<typeof loader>();

  return (
    <div className="blog-container">
      <header className="blog-header">
        <h1>기술 블로그</h1>

        {/* 검색 */}
        <Form method="get" className="search-form">
          <input
            name="search"
            type="search"
            placeholder="검색..."
            defaultValue={search}
          />
          {category && (
            <input type="hidden" name="category" value={category} />
          )}
        </Form>
      </header>

      <div className="blog-layout">
        {/* 사이드바 */}
        <aside className="sidebar">
          <h3>카테고리</h3>
          <Form method="get">
            {search && <input type="hidden" name="search" value={search} />}
            <ul>
              <li>
                <button
                  name="category"
                  value=""
                  className={!category ? "active" : ""}
                >
                  전체
                </button>
              </li>
              {categories.map(cat => (
                <li key={cat}>
                  <button
                    name="category"
                    value={cat}
                    className={category === cat ? "active" : ""}
                  >
                    {cat}
                  </button>
                </li>
              ))}
            </ul>
          </Form>
        </aside>

        {/* 포스트 목록 */}
        <main className="posts-grid">
          {posts.length === 0 ? (
            <p>포스트가 없습니다.</p>
          ) : (
            posts.map(post => (
              <article key={post.id} className="post-card">
                <Link to={`/blog/${post.slug}`} prefetch="intent">
                  {post.coverImage && (
                    <img src={post.coverImage} alt={post.title} />
                  )}

                  <div className="post-content">
                    <span className="category">{post.category}</span>
                    <h2>{post.title}</h2>
                    <p>{post.excerpt}</p>

                    <div className="post-meta">
                      <div className="author">
                        <img src={post.author.avatar} alt={post.author.name} />
                        <span>{post.author.name}</span>
                      </div>

                      <div className="stats">
                        <span>{formatDate(post.publishedAt)}</span>
                        <span>💬 {post._count.comments}</span>
                      </div>
                    </div>
                  </div>
                </Link>
              </article>
            ))
          )}
        </main>
      </div>
    </div>
  );
}

const formatDate = (date: string) => {
  return new Intl.DateTimeFormat("ko-KR", {
    year: "numeric",
    month: "long",
    day: "numeric"
  }).format(new Date(date));
};
```

### 2. 블로그 포스트 상세

```typescript
// app/routes/blog.$slug.tsx
import { json, LoaderFunctionArgs } from "@remix-run/node";
import { useLoaderData, Link } from "@remix-run/react";
import { getMDXComponent } from "mdx-bundler/client";
import { useMemo } from "react";
import { db } from "~/utils/db.server";
import { bundleMDX } from "~/utils/mdx.server";

export const loader = async ({ params }: LoaderFunctionArgs) => {
  const post = await db.post.findUnique({
    where: { slug: params.slug },
    include: {
      author: true,
      comments: {
        include: { author: true },
        orderBy: { createdAt: "desc" }
      }
    }
  });

  if (!post || !post.published) {
    throw new Response("Not Found", { status: 404 });
  }

  // MDX 컴파일
  const { code, frontmatter } = await bundleMDX({
    source: post.content
  });

  // 조회수 증가
  await db.post.update({
    where: { id: post.id },
    data: { views: { increment: 1 } }
  });

  return json({ post, code, frontmatter });
};

export const meta: MetaFunction<typeof loader> = ({ data }) => {
  if (!data) return [{ title: "Post not found" }];

  const { post } = data;

  return [
    { title: `${post.title} - 블로그` },
    { name: "description", content: post.excerpt },
    { name: "author", content: post.author.name },
    { property: "og:title", content: post.title },
    { property: "og:description", content: post.excerpt },
    { property: "og:image", content: post.coverImage },
    { property: "og:type", content: "article" },
    { property: "article:published_time", content: post.publishedAt },
    { property: "article:author", content: post.author.name },
  ];
};

export default function BlogPost() {
  const { post, code } = useLoaderData<typeof loader>();

  // MDX 컴포넌트 생성
  const Component = useMemo(() => getMDXComponent(code), [code]);

  return (
    <article className="blog-post">
      <header className="post-header">
        <Link to="/blog" className="back-link">
          ← 블로그 목록
        </Link>

        <span className="category">{post.category}</span>
        <h1>{post.title}</h1>

        <div className="post-meta">
          <div className="author-info">
            <img src={post.author.avatar} alt={post.author.name} />
            <div>
              <p className="author-name">{post.author.name}</p>
              <p className="post-date">{formatDate(post.publishedAt)}</p>
            </div>
          </div>

          <div className="stats">
            <span>👁 {post.views}</span>
            <span>💬 {post.comments.length}</span>
          </div>
        </div>

        {post.coverImage && (
          <img
            src={post.coverImage}
            alt={post.title}
            className="cover-image"
          />
        )}
      </header>

      {/* MDX 컨텐츠 */}
      <div className="post-content">
        <Component />
      </div>

      {/* 댓글 */}
      <section className="comments">
        <h2>댓글 {post.comments.length}</h2>

        <ul>
          {post.comments.map(comment => (
            <li key={comment.id} className="comment">
              <div className="comment-header">
                <img src={comment.author.avatar} alt={comment.author.name} />
                <div>
                  <p className="author-name">{comment.author.name}</p>
                  <p className="comment-date">{formatDate(comment.createdAt)}</p>
                </div>
              </div>
              <p className="comment-content">{comment.content}</p>
            </li>
          ))}
        </ul>
      </section>
    </article>
  );
}
```

---

## 프로젝트 3: 인증 시스템

세션 기반 인증을 구현합니다.

### 1. 세션 관리

```typescript
// app/utils/session.server.ts
import { createCookieSessionStorage, redirect } from "@remix-run/node";
import bcrypt from "bcryptjs";
import { db } from "./db.server";

// 세션 스토리지 생성
const sessionSecret = process.env.SESSION_SECRET;
if (!sessionSecret) {
  throw new Error("SESSION_SECRET must be set");
}

const storage = createCookieSessionStorage({
  cookie: {
    name: "app_session",
    secure: process.env.NODE_ENV === "production",
    secrets: [sessionSecret],
    sameSite: "lax",
    path: "/",
    maxAge: 60 * 60 * 24 * 30, // 30일
    httpOnly: true
  }
});

export const createUserSession = async (userId: string, redirectTo: string) => {
  const session = await storage.getSession();
  session.set("userId", userId);

  return redirect(redirectTo, {
    headers: {
      "Set-Cookie": await storage.commitSession(session)
    }
  });
};

export const getUserSession = (request: Request) => {
  return storage.getSession(request.headers.get("Cookie"));
};

export const getUserId = async (request: Request): Promise<string | null> => {
  const session = await getUserSession(request);
  const userId = session.get("userId");
  return userId || null;
};

export const requireUserId = async (
  request: Request,
  redirectTo: string = new URL(request.url).pathname
) => {
  const userId = await getUserId(request);
  if (!userId) {
    const searchParams = new URLSearchParams([["redirectTo", redirectTo]]);
    throw redirect(`/login?${searchParams}`);
  }
  return userId;
};

export const getUser = async (request: Request) => {
  const userId = await getUserId(request);
  if (!userId) return null;

  const user = await db.user.findUnique({
    where: { id: userId },
    select: { id: true, email: true, name: true }
  });

  return user;
};

export const logout = async (request: Request) => {
  const session = await getUserSession(request);

  return redirect("/", {
    headers: {
      "Set-Cookie": await storage.destroySession(session)
    }
  });
};

export const register = async (email: string, password: string, name: string) => {
  const hashedPassword = await bcrypt.hash(password, 10);

  const user = await db.user.create({
    data: {
      email,
      name,
      password: hashedPassword
    }
  });

  return user;
};

export const login = async (email: string, password: string) => {
  const user = await db.user.findUnique({
    where: { email }
  });

  if (!user) return null;

  const isValid = await bcrypt.compare(password, user.password);
  if (!isValid) return null;

  return user;
};
```

### 2. 로그인 페이지

```typescript
// app/routes/login.tsx
import { json, ActionFunctionArgs, LoaderFunctionArgs } from "@remix-run/node";
import { Form, useActionData, useSearchParams, Link } from "@remix-run/react";
import { login, createUserSession, getUserId } from "~/utils/session.server";

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const userId = await getUserId(request);
  if (userId) {
    return redirect("/dashboard");
  }
  return json({});
};

export const action = async ({ request }: ActionFunctionArgs) => {
  const formData = await request.formData();
  const email = formData.get("email")?.toString();
  const password = formData.get("password")?.toString();
  const redirectTo = formData.get("redirectTo")?.toString() || "/dashboard";

  // 유효성 검증
  const errors: Record<string, string> = {};

  if (!email || !email.includes("@")) {
    errors.email = "올바른 이메일을 입력해주세요";
  }

  if (!password || password.length < 6) {
    errors.password = "비밀번호는 6자 이상이어야 합니다";
  }

  if (Object.keys(errors).length > 0) {
    return json({ errors }, { status: 400 });
  }

  // 로그인
  const user = await login(email, password);

  if (!user) {
    return json(
      { errors: { email: "이메일 또는 비밀번호가 올바르지 않습니다" } },
      { status: 401 }
    );
  }

  return createUserSession(user.id, redirectTo);
};

export default function Login() {
  const actionData = useActionData<typeof action>();
  const [searchParams] = useSearchParams();

  return (
    <div className="auth-container">
      <div className="auth-card">
        <h1>로그인</h1>

        <Form method="post">
          <input
            type="hidden"
            name="redirectTo"
            value={searchParams.get("redirectTo") || "/dashboard"}
          />

          <div className="form-group">
            <label htmlFor="email">이메일</label>
            <input
              id="email"
              name="email"
              type="email"
              autoComplete="email"
              required
              aria-invalid={actionData?.errors?.email ? true : undefined}
            />
            {actionData?.errors?.email && (
              <p className="error">{actionData.errors.email}</p>
            )}
          </div>

          <div className="form-group">
            <label htmlFor="password">비밀번호</label>
            <input
              id="password"
              name="password"
              type="password"
              autoComplete="current-password"
              required
              aria-invalid={actionData?.errors?.password ? true : undefined}
            />
            {actionData?.errors?.password && (
              <p className="error">{actionData.errors.password}</p>
            )}
          </div>

          <button type="submit" className="btn-primary">
            로그인
          </button>
        </Form>

        <p className="auth-footer">
          계정이 없으신가요?{" "}
          <Link to="/register">회원가입</Link>
        </p>
      </div>
    </div>
  );
}
```

### 3. 보호된 라우트

```typescript
// app/routes/dashboard.tsx
import { json, LoaderFunctionArgs } from "@remix-run/node";
import { useLoaderData, Form, Outlet } from "@remix-run/react";
import { requireUserId, getUser } from "~/utils/session.server";

export const loader = async ({ request }: LoaderFunctionArgs) => {
  await requireUserId(request); // 인증 필수
  const user = await getUser(request);

  return json({ user });
};

export default function Dashboard() {
  const { user } = useLoaderData<typeof loader>();

  return (
    <div className="dashboard">
      <header className="dashboard-header">
        <h1>대시보드</h1>

        <div className="user-menu">
          <span>안녕하세요, {user.name}님</span>
          <Form action="/logout" method="post">
            <button type="submit">로그아웃</button>
          </Form>
        </div>
      </header>

      <div className="dashboard-layout">
        <nav className="sidebar">
          <Link to="/dashboard">홈</Link>
          <Link to="/dashboard/profile">프로필</Link>
          <Link to="/dashboard/settings">설정</Link>
        </nav>

        <main className="dashboard-content">
          <Outlet />
        </main>
      </div>
    </div>
  );
}
```

---

## 프로젝트 4: 전자상거래 장바구니

세션을 사용한 장바구니 시스템입니다.

### 1. 장바구니 세션 관리

```typescript
// app/utils/cart.server.ts
import { createCookieSessionStorage } from "@remix-run/node";

const cartStorage = createCookieSessionStorage({
  cookie: {
    name: "cart",
    secure: process.env.NODE_ENV === "production",
    secrets: [process.env.SESSION_SECRET!],
    sameSite: "lax",
    path: "/",
    maxAge: 60 * 60 * 24 * 7, // 7일
    httpOnly: true
  }
});

export type CartItem = {
  productId: string;
  quantity: number;
  price: number;
  name: string;
  image: string;
};

export const getCart = async (request: Request): Promise<CartItem[]> => {
  const session = await cartStorage.getSession(request.headers.get("Cookie"));
  return session.get("cart") || [];
};

export const addToCart = async (request: Request, item: CartItem) => {
  const session = await cartStorage.getSession(request.headers.get("Cookie"));
  const cart: CartItem[] = session.get("cart") || [];

  const existingItem = cart.find(i => i.productId === item.productId);

  if (existingItem) {
    existingItem.quantity += item.quantity;
  } else {
    cart.push(item);
  }

  session.set("cart", cart);

  return {
    cart,
    headers: {
      "Set-Cookie": await cartStorage.commitSession(session)
    }
  };
};

export const removeFromCart = async (request: Request, productId: string) => {
  const session = await cartStorage.getSession(request.headers.get("Cookie"));
  const cart: CartItem[] = session.get("cart") || [];

  const newCart = cart.filter(item => item.productId !== productId);

  session.set("cart", newCart);

  return {
    cart: newCart,
    headers: {
      "Set-Cookie": await cartStorage.commitSession(session)
    }
  };
};

export const updateQuantity = async (
  request: Request,
  productId: string,
  quantity: number
) => {
  const session = await cartStorage.getSession(request.headers.get("Cookie"));
  const cart: CartItem[] = session.get("cart") || [];

  const item = cart.find(i => i.productId === productId);

  if (item) {
    if (quantity <= 0) {
      return removeFromCart(request, productId);
    }
    item.quantity = quantity;
  }

  session.set("cart", cart);

  return {
    cart,
    headers: {
      "Set-Cookie": await cartStorage.commitSession(session)
    }
  };
};

export const clearCart = async (request: Request) => {
  const session = await cartStorage.getSession(request.headers.get("Cookie"));
  session.set("cart", []);

  return {
    headers: {
      "Set-Cookie": await cartStorage.commitSession(session)
    }
  };
};
```

### 2. 장바구니 페이지

```typescript
// app/routes/cart.tsx
import { json, ActionFunctionArgs, LoaderFunctionArgs } from "@remix-run/node";
import { useLoaderData, Form, useFetcher } from "@remix-run/react";
import {
  getCart,
  updateQuantity,
  removeFromCart,
  clearCart
} from "~/utils/cart.server";

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const cart = await getCart(request);

  const subtotal = cart.reduce(
    (sum, item) => sum + item.price * item.quantity,
    0
  );

  const shipping = subtotal > 50 ? 0 : 5;
  const tax = subtotal * 0.1;
  const total = subtotal + shipping + tax;

  return json({ cart, subtotal, shipping, tax, total });
};

export const action = async ({ request }: ActionFunctionArgs) => {
  const formData = await request.formData();
  const intent = formData.get("intent");

  switch (intent) {
    case "update-quantity": {
      const productId = formData.get("productId")?.toString()!;
      const quantity = parseInt(formData.get("quantity")?.toString() || "1");

      const { cart, headers } = await updateQuantity(request, productId, quantity);

      return json({ cart }, { headers });
    }

    case "remove": {
      const productId = formData.get("productId")?.toString()!;

      const { cart, headers } = await removeFromCart(request, productId);

      return json({ cart }, { headers });
    }

    case "clear": {
      const { headers } = await clearCart(request);

      return json({ cart: [] }, { headers });
    }

    default:
      return json({ error: "Invalid intent" }, { status: 400 });
  }
};

export default function Cart() {
  const { cart, subtotal, shipping, tax, total } = useLoaderData<typeof loader>();

  if (cart.length === 0) {
    return (
      <div className="empty-cart">
        <h1>장바구니가 비어있습니다</h1>
        <Link to="/products">쇼핑 계속하기</Link>
      </div>
    );
  }

  return (
    <div className="cart-container">
      <h1>장바구니</h1>

      <div className="cart-layout">
        {/* 장바구니 아이템 */}
        <div className="cart-items">
          {cart.map(item => (
            <CartItem key={item.productId} item={item} />
          ))}

          <Form method="post">
            <input type="hidden" name="intent" value="clear" />
            <button type="submit" className="clear-cart">
              장바구니 비우기
            </button>
          </Form>
        </div>

        {/* 주문 요약 */}
        <div className="order-summary">
          <h2>주문 요약</h2>

          <dl>
            <dt>소계</dt>
            <dd>${subtotal.toFixed(2)}</dd>

            <dt>배송비</dt>
            <dd>{shipping === 0 ? "무료" : `$${shipping.toFixed(2)}`}</dd>

            <dt>세금</dt>
            <dd>${tax.toFixed(2)}</dd>

            <dt className="total">합계</dt>
            <dd className="total">${total.toFixed(2)}</dd>
          </dl>

          <Link to="/checkout" className="btn-primary btn-block">
            결제하기
          </Link>
        </div>
      </div>
    </div>
  );
}

// 장바구니 아이템 컴포넌트
const CartItem = ({ item }) => {
  const fetcher = useFetcher();

  const quantity = fetcher.formData?.get("quantity")
    ? parseInt(fetcher.formData.get("quantity")!.toString())
    : item.quantity;

  return (
    <div className="cart-item">
      <img src={item.image} alt={item.name} />

      <div className="item-details">
        <h3>{item.name}</h3>
        <p className="price">${item.price.toFixed(2)}</p>
      </div>

      <fetcher.Form method="post" className="quantity-control">
        <input type="hidden" name="intent" value="update-quantity" />
        <input type="hidden" name="productId" value={item.productId} />

        <button
          name="quantity"
          value={quantity - 1}
          disabled={quantity <= 1}
        >
          -
        </button>

        <span>{quantity}</span>

        <button
          name="quantity"
          value={quantity + 1}
        >
          +
        </button>
      </fetcher.Form>

      <p className="item-total">
        ${(item.price * quantity).toFixed(2)}
      </p>

      <fetcher.Form method="post">
        <input type="hidden" name="intent" value="remove" />
        <input type="hidden" name="productId" value={item.productId} />
        <button type="submit" className="remove-item">
          ✕
        </button>
      </fetcher.Form>
    </div>
  );
};
```

---

## 배포 가이드

### 1. Vercel 배포

```bash
# Vercel CLI 설치
pnpm add -g vercel

# 로그인
vercel login

# 배포
vercel

# 프로덕션 배포
vercel --prod
```

### 2. Fly.io 배포

```bash
# Fly CLI 설치
curl -L https://fly.io/install.sh | sh

# 로그인
fly auth login

# 앱 생성
fly launch

# 배포
fly deploy
```

### 3. Railway 배포

```bash
# Railway CLI 설치
npm i -g @railway/cli

# 로그인
railway login

# 프로젝트 초기화
railway init

# 배포
railway up
```

---

## Best Practices 요약

### 1. 라우팅
- ✅ 중첩 라우팅을 활용하여 레이아웃 재사용
- ✅ 동적 세그먼트는 명확한 이름 사용
- ✅ Pathless 라우트로 공통 로직 그룹핑

### 2. 데이터 로딩
- ✅ loader는 서버에서만 실행되므로 DB 직접 접근 가능
- ✅ 병렬 데이터 로딩 활용
- ✅ 적절한 HTTP 캐싱 전략 사용

### 3. 폼 처리
- ✅ Remix Form 컴포넌트 사용
- ✅ 서버 사이드 유효성 검증 필수
- ✅ 낙관적 UI로 사용자 경험 향상

### 4. 에러 처리
- ✅ 각 라우트에 ErrorBoundary 구현
- ✅ 의미있는 에러 메시지 제공
- ✅ 프로덕션에서 에러 로깅

### 5. 성능 최적화
- ✅ Prefetch로 체감 속도 향상
- ✅ 이미지 최적화 및 lazy loading
- ✅ 불필요한 재검증 방지

### 6. SEO
- ✅ meta 함수로 동적 메타 태그
- ✅ 적절한 캐싱 헤더 설정
- ✅ Sitemap 및 robots.txt 제공

---

## 학습 완료!

축하합니다! Remix의 모든 핵심 개념을 학습하셨습니다. 🎉

### 다음 단계
1. **실전 프로젝트 구축**: 위의 예제를 기반으로 자신만의 프로젝트 시작
2. **Remix 공식 문서**: https://remix.run/docs
3. **커뮤니티**: Remix Discord, GitHub Discussions 참여
4. **고급 주제**:
   - Server-Sent Events (SSE)
   - WebSocket 통합
   - 마이크로프론트엔드
   - 모노레포 구성

**Happy Coding with Remix! 🚀**
