# Remix 완벽 가이드 - 05. 에러 처리와 메타데이터

## 목차
1. [ErrorBoundary 완벽 가이드](#errorboundary-완벽-가이드)
2. [에러 처리 전략](#에러-처리-전략)
3. [useRouteError 활용](#userouteerror-활용)
4. [Meta 함수로 SEO 최적화](#meta-함수로-seo-최적화)
5. [동적 메타 태그](#동적-메타-태그)
6. [Links 함수](#links-함수)
7. [실전 패턴](#실전-패턴)

---

## ErrorBoundary 완벽 가이드

Remix의 ErrorBoundary는 라우트 레벨에서 에러를 우아하게 처리합니다.

### 1. 기본 사용법

```typescript
// app/routes/posts.$postId.tsx
import { useRouteError, isRouteErrorResponse } from "@remix-run/react";

export const loader = async ({ params }: LoaderFunctionArgs) => {
  const post = await db.post.findUnique({
    where: { id: params.postId }
  });

  if (!post) {
    // 404 에러 발생
    throw new Response("Post not found", { status: 404 });
  }

  return json({ post });
};

export default function Post() {
  const { post } = useLoaderData<typeof loader>();
  return <div>{post.title}</div>;
}

// 에러 발생 시 자동으로 이 컴포넌트가 렌더링됨
export function ErrorBoundary() {
  const error = useRouteError();

  if (isRouteErrorResponse(error)) {
    return (
      <div>
        <h1>{error.status} {error.statusText}</h1>
        <p>{error.data}</p>
      </div>
    );
  }

  return (
    <div>
      <h1>예상치 못한 오류가 발생했습니다</h1>
      <p>죄송합니다. 문제가 발생했습니다.</p>
    </div>
  );
}
```

**ErrorBoundary의 장점:**
- ✅ 에러가 발생한 라우트만 영향을 받음 (부모 레이아웃은 유지)
- ✅ 중첩 라우팅에서 계층별 에러 처리 가능
- ✅ 자동으로 에러 로깅 및 복구

### 2. 다양한 에러 타입 처리

```typescript
import { useRouteError, isRouteErrorResponse } from "@remix-run/react";

export function ErrorBoundary() {
  const error = useRouteError();

  // Response 객체로 던진 에러
  if (isRouteErrorResponse(error)) {
    if (error.status === 404) {
      return (
        <div className="error-container">
          <h1>404 - 페이지를 찾을 수 없습니다</h1>
          <p>{error.data}</p>
          <Link to="/">홈으로 돌아가기</Link>
        </div>
      );
    }

    if (error.status === 401) {
      return (
        <div className="error-container">
          <h1>401 - 인증이 필요합니다</h1>
          <Link to="/login">로그인하기</Link>
        </div>
      );
    }

    if (error.status === 403) {
      return (
        <div className="error-container">
          <h1>403 - 접근 권한이 없습니다</h1>
          <Link to="/">홈으로 돌아가기</Link>
        </div>
      );
    }

    return (
      <div className="error-container">
        <h1>{error.status} {error.statusText}</h1>
        <p>{error.data}</p>
      </div>
    );
  }

  // JavaScript Error 객체
  if (error instanceof Error) {
    return (
      <div className="error-container">
        <h1>오류가 발생했습니다</h1>
        <p>{error.message}</p>
        {process.env.NODE_ENV === "development" && (
          <pre>{error.stack}</pre>
        )}
      </div>
    );
  }

  // 알 수 없는 에러
  return (
    <div className="error-container">
      <h1>알 수 없는 오류</h1>
      <p>예상치 못한 문제가 발생했습니다.</p>
    </div>
  );
}
```

### 3. 중첩 ErrorBoundary

```typescript
// app/routes/dashboard.tsx
// 대시보드 레벨의 에러 처리
export function ErrorBoundary() {
  return (
    <div className="dashboard-error">
      <h1>대시보드 오류</h1>
      <p>대시보드를 불러오는 중 문제가 발생했습니다.</p>
      <Link to="/">홈으로</Link>
    </div>
  );
}

// app/routes/dashboard.settings.tsx
// 설정 페이지의 에러 처리
export function ErrorBoundary() {
  const error = useRouteError();

  return (
    <div className="settings-error">
      <h2>설정 오류</h2>
      <p>설정을 불러오는 중 문제가 발생했습니다.</p>
      <Link to="/dashboard">대시보드로 돌아가기</Link>
    </div>
  );
}

// 에러는 가장 가까운 ErrorBoundary에서 캐치됨
// settings에서 에러 → dashboard.settings의 ErrorBoundary
// dashboard에서 에러 → dashboard의 ErrorBoundary
```

### 4. 전역 ErrorBoundary

```typescript
// app/root.tsx
import {
  Links,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
  useRouteError,
  isRouteErrorResponse
} from "@remix-run/react";

export function ErrorBoundary() {
  const error = useRouteError();

  return (
    <html lang="ko">
      <head>
        <Meta />
        <Links />
      </head>
      <body>
        <div className="global-error">
          {isRouteErrorResponse(error) ? (
            <>
              <h1>{error.status} {error.statusText}</h1>
              <p>{error.data}</p>
            </>
          ) : (
            <>
              <h1>애플리케이션 오류</h1>
              <p>죄송합니다. 예상치 못한 문제가 발생했습니다.</p>
            </>
          )}
        </div>
        <Scripts />
      </body>
    </html>
  );
}
```

---

## 에러 처리 전략

### 1. Loader에서 에러 던지기

```typescript
export const loader = async ({ params, request }: LoaderFunctionArgs) => {
  // 1. 404 에러
  const user = await db.user.findUnique({
    where: { id: params.userId }
  });

  if (!user) {
    throw new Response("User not found", {
      status: 404,
      statusText: "Not Found"
    });
  }

  // 2. 인증 에러
  const session = await getSession(request.headers.get("Cookie"));
  if (!session.has("userId")) {
    throw new Response("Unauthorized", { status: 401 });
  }

  // 3. 권한 에러
  if (user.id !== session.get("userId")) {
    throw new Response("Forbidden", { status: 403 });
  }

  // 4. 커스텀 에러 데이터
  if (user.status === "banned") {
    throw json(
      {
        message: "계정이 정지되었습니다",
        reason: user.banReason,
        until: user.banUntil
      },
      { status: 403 }
    );
  }

  return json({ user });
};
```

### 2. Action에서 에러 처리

```typescript
export const action = async ({ request }: ActionFunctionArgs) => {
  const formData = await request.formData();

  try {
    const result = await createPost(formData);
    return redirect(`/posts/${result.id}`);
  } catch (error) {
    // 예상된 비즈니스 로직 에러
    if (error instanceof ValidationError) {
      return json(
        { errors: error.errors },
        { status: 400 }
      );
    }

    // 데이터베이스 에러
    if (error instanceof PrismaClientKnownRequestError) {
      if (error.code === "P2002") {
        return json(
          { error: "이미 존재하는 데이터입니다" },
          { status: 409 }
        );
      }
    }

    // 예상치 못한 에러는 ErrorBoundary로
    throw error;
  }
};
```

### 3. 에러 로깅

```typescript
// app/utils/logger.ts
export const logError = (error: unknown, context?: Record<string, any>) => {
  if (process.env.NODE_ENV === "production") {
    // Sentry, LogRocket 등으로 전송
    Sentry.captureException(error, { extra: context });
  } else {
    console.error("Error:", error, context);
  }
};

// 사용 예시
export const loader = async ({ params }: LoaderFunctionArgs) => {
  try {
    const data = await fetchData(params.id);
    return json({ data });
  } catch (error) {
    logError(error, {
      route: "/posts/:id",
      params,
      timestamp: new Date().toISOString()
    });

    throw new Response("Internal Server Error", { status: 500 });
  }
};
```

---

## useRouteError 활용

### 1. 타입 가드

```typescript
import { isRouteErrorResponse } from "@remix-run/react";

export function ErrorBoundary() {
  const error = useRouteError();

  // Response 객체 에러인지 확인
  if (isRouteErrorResponse(error)) {
    // error.status, error.statusText, error.data에 접근 가능
    return <div>{error.status}: {error.data}</div>;
  }

  // JavaScript Error 객체인지 확인
  if (error instanceof Error) {
    // error.message, error.stack에 접근 가능
    return <div>{error.message}</div>;
  }

  // 알 수 없는 타입
  return <div>Unknown error</div>;
}
```

### 2. 에러 정보 추출

```typescript
export function ErrorBoundary() {
  const error = useRouteError();

  const getErrorMessage = (error: unknown): string => {
    if (isRouteErrorResponse(error)) {
      return error.data?.message || error.data || error.statusText;
    }

    if (error instanceof Error) {
      return error.message;
    }

    if (typeof error === "string") {
      return error;
    }

    return "알 수 없는 오류가 발생했습니다";
  };

  const getErrorStatus = (error: unknown): number | undefined => {
    if (isRouteErrorResponse(error)) {
      return error.status;
    }
    return undefined;
  };

  return (
    <div>
      <h1>오류 {getErrorStatus(error)}</h1>
      <p>{getErrorMessage(error)}</p>
    </div>
  );
}
```

---

## Meta 함수로 SEO 최적화

Meta 함수는 페이지의 메타데이터를 동적으로 설정합니다.

### 1. 기본 메타 태그

```typescript
// app/routes/_index.tsx
import type { MetaFunction } from "@remix-run/node";

export const meta: MetaFunction = () => {
  return [
    { title: "홈페이지 - My App" },
    { name: "description", content: "환영합니다!" },
    { name: "keywords", content: "remix, react, web" },

    // Open Graph (소셜 미디어)
    { property: "og:title", content: "홈페이지 - My App" },
    { property: "og:description", content: "환영합니다!" },
    { property: "og:type", content: "website" },
    { property: "og:url", content: "https://myapp.com" },
    { property: "og:image", content: "https://myapp.com/og-image.jpg" },

    // Twitter Card
    { name: "twitter:card", content: "summary_large_image" },
    { name: "twitter:title", content: "홈페이지 - My App" },
    { name: "twitter:description", content: "환영합니다!" },
    { name: "twitter:image", content: "https://myapp.com/twitter-image.jpg" },
  ];
};
```

### 2. 동적 메타 태그 (loader 데이터 사용)

```typescript
// app/routes/posts.$postId.tsx
export const loader = async ({ params }: LoaderFunctionArgs) => {
  const post = await db.post.findUnique({
    where: { id: params.postId },
    include: { author: true }
  });

  if (!post) {
    throw new Response("Not Found", { status: 404 });
  }

  return json({ post });
};

export const meta: MetaFunction<typeof loader> = ({ data }) => {
  if (!data) {
    return [{ title: "Post not found" }];
  }

  const { post } = data;

  return [
    { title: `${post.title} - Blog` },
    { name: "description", content: post.excerpt },
    { name: "author", content: post.author.name },

    // Open Graph
    { property: "og:title", content: post.title },
    { property: "og:description", content: post.excerpt },
    { property: "og:type", content: "article" },
    { property: "og:image", content: post.coverImage },
    { property: "article:published_time", content: post.publishedAt },
    { property: "article:author", content: post.author.name },

    // Twitter Card
    { name: "twitter:card", content: "summary_large_image" },
    { name: "twitter:title", content: post.title },
    { name: "twitter:description", content: post.excerpt },
    { name: "twitter:image", content: post.coverImage },
  ];
};
```

### 3. 부모 메타 상속

```typescript
// app/routes/blog.tsx
export const meta: MetaFunction = () => {
  return [
    { title: "블로그" },
    { name: "description", content: "기술 블로그" }
  ];
};

// app/routes/blog.$postId.tsx
export const meta: MetaFunction<typeof loader> = ({ data, matches }) => {
  // matches: 부모 라우트들의 메타 데이터
  const parentMeta = matches.find(
    match => match.id === "routes/blog"
  )?.meta || [];

  return [
    ...parentMeta, // 부모 메타 상속
    { title: `${data.post.title} - 블로그` },
    { name: "description", content: data.post.excerpt }
  ];
};
```

---

## 동적 메타 태그

### 1. 조건부 메타 태그

```typescript
export const meta: MetaFunction<typeof loader> = ({ data }) => {
  const baseMeta = [
    { title: data.user.name },
    { name: "description", content: data.user.bio }
  ];

  // 프리미엄 사용자만 추가 메타 태그
  if (data.user.isPremium) {
    baseMeta.push(
      { name: "robots", content: "index, follow" },
      { property: "og:image", content: data.user.premiumAvatar }
    );
  } else {
    baseMeta.push(
      { name: "robots", content: "noindex, nofollow" }
    );
  }

  return baseMeta;
};
```

### 2. 다국어 메타 태그

```typescript
export const loader = async ({ request }: LoaderFunctionArgs) => {
  const locale = await getLocale(request);
  const translations = await getTranslations(locale);

  return json({ locale, translations });
};

export const meta: MetaFunction<typeof loader> = ({ data }) => {
  const t = data.translations;

  return [
    { title: t.pageTitle },
    { name: "description", content: t.pageDescription },
    { property: "og:locale", content: data.locale },

    // 대체 언어
    { property: "og:locale:alternate", content: "en_US" },
    { property: "og:locale:alternate", content: "ko_KR" },
  ];
};
```

### 3. JSON-LD 구조화 데이터

```typescript
export const meta: MetaFunction<typeof loader> = ({ data }) => {
  const jsonLd = {
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": data.post.title,
    "description": data.post.excerpt,
    "image": data.post.coverImage,
    "datePublished": data.post.publishedAt,
    "dateModified": data.post.updatedAt,
    "author": {
      "@type": "Person",
      "name": data.post.author.name
    }
  };

  return [
    { title: data.post.title },
    {
      "script:ld+json": jsonLd
    }
  ];
};
```

---

## Links 함수

Links 함수는 `<link>` 태그를 동적으로 추가합니다.

### 1. 기본 사용법

```typescript
import type { LinksFunction } from "@remix-run/node";
import styles from "~/styles/posts.css";

export const links: LinksFunction = () => {
  return [
    // 스타일시트
    { rel: "stylesheet", href: styles },

    // Preload
    {
      rel: "preload",
      href: "/fonts/inter.woff2",
      as: "font",
      type: "font/woff2",
      crossOrigin: "anonymous"
    },

    // Prefetch
    {
      rel: "prefetch",
      href: "/api/data",
      as: "fetch"
    },

    // 파비콘
    {
      rel: "icon",
      type: "image/png",
      href: "/favicon.png"
    },

    // Canonical URL
    {
      rel: "canonical",
      href: "https://myapp.com/posts"
    }
  ];
};
```

### 2. 조건부 링크

```typescript
export const links: LinksFunction = () => {
  const links = [
    { rel: "stylesheet", href: baseStyles }
  ];

  // 다크 모드 스타일
  if (typeof window !== "undefined" && window.matchMedia("(prefers-color-scheme: dark)").matches) {
    links.push({
      rel: "stylesheet",
      href: darkStyles
    });
  }

  return links;
};
```

### 3. 외부 리소스

```typescript
export const links: LinksFunction = () => {
  return [
    // Google Fonts
    {
      rel: "preconnect",
      href: "https://fonts.googleapis.com"
    },
    {
      rel: "preconnect",
      href: "https://fonts.gstatic.com",
      crossOrigin: "anonymous"
    },
    {
      rel: "stylesheet",
      href: "https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap"
    },

    // CDN 리소스
    {
      rel: "stylesheet",
      href: "https://cdn.jsdelivr.net/npm/highlight.js@11/styles/github.css"
    }
  ];
};
```

---

## 실전 패턴

### 1. 재사용 가능한 메타 생성 함수

```typescript
// app/utils/meta.ts
type MetaDescriptor = ReturnType<MetaFunction>;

export const createMeta = ({
  title,
  description,
  image,
  url,
  type = "website"
}: {
  title: string;
  description: string;
  image?: string;
  url?: string;
  type?: string;
}): MetaDescriptor => {
  return [
    { title },
    { name: "description", content: description },

    // Open Graph
    { property: "og:title", content: title },
    { property: "og:description", content: description },
    { property: "og:type", content: type },
    ...(url ? [{ property: "og:url", content: url }] : []),
    ...(image ? [{ property: "og:image", content: image }] : []),

    // Twitter
    { name: "twitter:card", content: "summary_large_image" },
    { name: "twitter:title", content: title },
    { name: "twitter:description", content: description },
    ...(image ? [{ name: "twitter:image", content: image }] : []),
  ];
};

// 사용 예시
export const meta: MetaFunction<typeof loader> = ({ data }) => {
  return createMeta({
    title: data.post.title,
    description: data.post.excerpt,
    image: data.post.coverImage,
    url: `https://myapp.com/posts/${data.post.slug}`,
    type: "article"
  });
};
```

### 2. 에러 페이지 스타일링

```typescript
// app/routes/posts.$postId.tsx
export const links: LinksFunction = () => {
  return [{ rel: "stylesheet", href: postStyles }];
};

export function ErrorBoundary() {
  const error = useRouteError();

  return (
    <div className="error-page">
      <style>{`
        .error-page {
          min-height: 100vh;
          display: flex;
          align-items: center;
          justify-content: center;
          padding: 2rem;
        }

        .error-content {
          max-width: 500px;
          text-align: center;
        }

        .error-title {
          font-size: 3rem;
          font-weight: bold;
          color: #dc2626;
        }

        .error-message {
          margin-top: 1rem;
          color: #6b7280;
        }

        .error-action {
          margin-top: 2rem;
        }
      `}</style>

      <div className="error-content">
        <h1 className="error-title">
          {isRouteErrorResponse(error) ? error.status : "오류"}
        </h1>
        <p className="error-message">
          {isRouteErrorResponse(error)
            ? error.data
            : "예상치 못한 오류가 발생했습니다"}
        </p>
        <div className="error-action">
          <Link to="/" className="button">
            홈으로 돌아가기
          </Link>
        </div>
      </div>
    </div>
  );
}
```

### 3. 404 페이지 커스터마이징

```typescript
// app/routes/$.tsx (Catch-all 라우트)
export const meta: MetaFunction = () => {
  return [
    { title: "404 - 페이지를 찾을 수 없습니다" },
    { name: "robots", content: "noindex, nofollow" }
  ];
};

export default function NotFound() {
  return (
    <div className="not-found">
      <h1>404</h1>
      <p>죄송합니다. 페이지를 찾을 수 없습니다.</p>

      <div className="suggestions">
        <h2>다음 페이지를 방문해보세요:</h2>
        <ul>
          <li><Link to="/">홈페이지</Link></li>
          <li><Link to="/blog">블로그</Link></li>
          <li><Link to="/contact">문의하기</Link></li>
        </ul>
      </div>
    </div>
  );
}
```

---

## 다음 단계

다음 문서에서는 Remix의 성능 최적화와 고급 기법을 상세히 알아보겠습니다:
- 코드 스플리팅 최적화
- 캐싱 전략
- 이미지 최적화
- 번들 사이즈 최적화

**계속 학습하기**: [06-성능최적화와-고급기법.md](./06-성능최적화와-고급기법.md)
