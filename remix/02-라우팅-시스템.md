# Remix 완벽 가이드 - 02. 라우팅 시스템

## 목차
1. [파일 기반 라우팅 기초](#파일-기반-라우팅-기초)
2. [중첩 라우팅 (Nested Routes)](#중첩-라우팅-nested-routes)
3. [동적 라우팅](#동적-라우팅)
4. [레이아웃 라우트](#레이아웃-라우트)
5. [Pathless 라우트](#pathless-라우트)
6. [Splat Routes (캐치올)](#splat-routes-캐치올)
7. [라우트 모듈 API](#라우트-모듈-api)
8. [내비게이션](#내비게이션)

---

## 파일 기반 라우팅 기초

Remix는 `app/routes/` 디렉토리의 파일 구조를 기반으로 자동으로 라우트를 생성합니다.

### 기본 라우팅 규칙

```
app/routes/
├── _index.tsx           → /
├── about.tsx            → /about
├── contact.tsx          → /contact
└── blog.tsx             → /blog
```

### 파일명 규칙

```typescript
// app/routes/_index.tsx
// URL: /
export default function Index() {
  return <h1>홈페이지</h1>;
}

// app/routes/about.tsx
// URL: /about
export default function About() {
  return <h1>소개</h1>;
}

// app/routes/contact.tsx
// URL: /contact
export default function Contact() {
  return <h1>연락처</h1>;
}
```

---

## 중첩 라우팅 (Nested Routes)

Remix의 가장 강력한 기능 중 하나로, 라우트를 계층적으로 구성할 수 있습니다.

### 1. Dot Notation (점 표기법)

```
app/routes/
├── blog.tsx                    → /blog (부모)
├── blog._index.tsx             → /blog (인덱스)
├── blog.posts.tsx              → /blog/posts
└── blog.authors.tsx            → /blog/authors
```

```typescript
// app/routes/blog.tsx (부모 레이아웃)
import { Outlet } from "@remix-run/react";

export default function BlogLayout() {
  return (
    <div>
      <nav>
        <Link to="/blog">블로그 홈</Link>
        <Link to="/blog/posts">포스트</Link>
        <Link to="/blog/authors">작성자</Link>
      </nav>
      <main>
        <Outlet /> {/* 자식 라우트가 여기 렌더링됨 */}
      </main>
    </div>
  );
}

// app/routes/blog._index.tsx
export default function BlogIndex() {
  return <h1>블로그 메인 페이지</h1>;
}

// app/routes/blog.posts.tsx
export default function BlogPosts() {
  return <h1>모든 포스트</h1>;
}
```

### 2. 폴더 기반 중첩

```
app/routes/
└── dashboard/
    ├── route.tsx              → /dashboard (부모)
    ├── _index.tsx             → /dashboard (인덱스)
    ├── settings.tsx           → /dashboard/settings
    └── analytics.tsx          → /dashboard/analytics
```

```typescript
// app/routes/dashboard/route.tsx
import { Outlet } from "@remix-run/react";

export default function DashboardLayout() {
  return (
    <div className="dashboard">
      <aside>
        <nav>
          <Link to="/dashboard">대시보드</Link>
          <Link to="/dashboard/settings">설정</Link>
          <Link to="/dashboard/analytics">분석</Link>
        </nav>
      </aside>
      <main>
        <Outlet />
      </main>
    </div>
  );
}
```

### 3. 중첩 라우팅의 장점

```typescript
// 각 레벨에서 독립적으로 데이터 로드
// app/routes/dashboard/route.tsx
export const loader = async () => {
  return json({ user: await getUser() }); // 사용자 정보
};

// app/routes/dashboard/settings.tsx
export const loader = async () => {
  return json({ settings: await getSettings() }); // 설정 정보
};

// 두 loader가 병렬로 실행됩니다! 🚀
```

**장점:**
- ✅ 병렬 데이터 로딩으로 성능 향상
- ✅ 각 레벨에서 독립적인 로딩/에러 상태 관리
- ✅ 코드 분할이 자동으로 이루어짐
- ✅ 레이아웃 재사용으로 코드 중복 감소

---

## 동적 라우팅

URL 파라미터를 사용하여 동적 라우트를 생성합니다.

### 1. 기본 동적 세그먼트

```
app/routes/
├── users.$userId.tsx          → /users/:userId
├── posts.$postId.tsx          → /posts/:postId
└── blog.$slug.tsx             → /blog/:slug
```

```typescript
// app/routes/users.$userId.tsx
import { json, LoaderFunctionArgs } from "@remix-run/node";
import { useLoaderData } from "@remix-run/react";

// $ 뒤의 이름으로 params에서 접근
export const loader = async ({ params }: LoaderFunctionArgs) => {
  const userId = params.userId; // URL에서 추출

  const user = await db.user.findUnique({
    where: { id: userId }
  });

  if (!user) {
    throw new Response("Not Found", { status: 404 });
  }

  return json({ user });
};

export default function UserProfile() {
  const { user } = useLoaderData<typeof loader>();

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}
```

### 2. 다중 동적 세그먼트

```
app/routes/
└── projects.$projectId.tasks.$taskId.tsx
    → /projects/:projectId/tasks/:taskId
```

```typescript
// app/routes/projects.$projectId.tasks.$taskId.tsx
export const loader = async ({ params }: LoaderFunctionArgs) => {
  const { projectId, taskId } = params;

  const task = await db.task.findUnique({
    where: {
      projectId,
      id: taskId
    }
  });

  return json({ task });
};
```

### 3. Optional 세그먼트

```
app/routes/
└── blog.($lang).tsx           → /blog 또는 /blog/ko
```

```typescript
// app/routes/blog.($lang).tsx
export const loader = async ({ params }: LoaderFunctionArgs) => {
  const lang = params.lang || 'en'; // 기본값 'en'

  const posts = await db.post.findMany({
    where: { language: lang }
  });

  return json({ posts, lang });
};
```

---

## 레이아웃 라우트

### 1. URL 경로 없는 레이아웃

언더스코어(`_`)로 시작하는 파일명은 URL 경로를 생성하지 않습니다.

```
app/routes/
├── _auth.tsx                  → 레이아웃만 (URL 없음)
├── _auth.login.tsx            → /login
├── _auth.register.tsx         → /register
└── _auth.forgot-password.tsx  → /forgot-password
```

```typescript
// app/routes/_auth.tsx
// 이 레이아웃은 /login, /register, /forgot-password에서 공유됨
export default function AuthLayout() {
  return (
    <div className="auth-container">
      <div className="auth-logo">
        <img src="/logo.png" alt="Logo" />
      </div>
      <div className="auth-form">
        <Outlet /> {/* login, register 등이 여기 렌더링 */}
      </div>
      <footer>© 2024 My App</footer>
    </div>
  );
}

// app/routes/_auth.login.tsx
export default function Login() {
  return (
    <Form method="post">
      <input name="email" type="email" />
      <input name="password" type="password" />
      <button type="submit">로그인</button>
    </Form>
  );
}
```

### 2. 레이아웃 제외하기

```
app/routes/
├── _index.tsx                 → / (root.tsx 레이아웃 사용)
├── about.tsx                  → /about (root.tsx 레이아웃 사용)
└── print.tsx                  → /print (root.tsx 레이아웃 사용 안 함)
```

```typescript
// app/routes/print.tsx
// root.tsx의 레이아웃을 사용하지 않으려면
export default function Print() {
  return (
    <html>
      <head>
        <title>인쇄용 페이지</title>
      </head>
      <body>
        <div>인쇄 최적화된 컨텐츠</div>
      </body>
    </html>
  );
}
```

---

## Pathless 라우트

URL을 변경하지 않고 레이아웃이나 로직만 공유하는 라우트입니다.

```
app/routes/
├── __marketing/               # 경로 없음
│   ├── route.tsx
│   ├── _index.tsx            → /
│   ├── about.tsx             → /about
│   └── pricing.tsx           → /pricing
└── __app/                     # 경로 없음
    ├── route.tsx
    ├── dashboard.tsx         → /dashboard
    └── profile.tsx           → /profile
```

```typescript
// app/routes/__marketing/route.tsx
// 마케팅 페이지들의 공통 레이아웃
export default function MarketingLayout() {
  return (
    <div>
      <header>
        <nav>{/* 마케팅용 네비게이션 */}</nav>
      </header>
      <Outlet />
      <footer>{/* 마케팅용 푸터 */}</footer>
    </div>
  );
}

// app/routes/__app/route.tsx
// 앱 페이지들의 공통 레이아웃
export default function AppLayout() {
  return (
    <div>
      <Sidebar />
      <main>
        <Outlet />
      </main>
    </div>
  );
}
```

---

## Splat Routes (캐치올)

모든 하위 경로를 캐치하는 라우트입니다.

```
app/routes/
└── docs.$.tsx                 → /docs/* (모든 하위 경로)
```

```typescript
// app/routes/docs.$.tsx
export const loader = async ({ params }: LoaderFunctionArgs) => {
  // params["*"]에 매칭된 전체 경로가 들어옴
  const slug = params["*"]; // "getting-started/installation"

  const doc = await getDocBySlug(slug);

  if (!doc) {
    throw new Response("Not Found", { status: 404 });
  }

  return json({ doc });
};

export default function Doc() {
  const { doc } = useLoaderData<typeof loader>();

  return (
    <article>
      <h1>{doc.title}</h1>
      <div dangerouslySetInnerHTML={{ __html: doc.html }} />
    </article>
  );
}
```

**사용 예시:**
```
/docs/getting-started          → params["*"] = "getting-started"
/docs/api/users/create         → params["*"] = "api/users/create"
/docs/a/b/c/d/e               → params["*"] = "a/b/c/d/e"
```

---

## 라우트 모듈 API

각 라우트 파일에서 export할 수 있는 함수들입니다.

### 1. default (Component)

```typescript
// 필수! UI를 렌더링하는 컴포넌트
export default function MyRoute() {
  return <div>컨텐츠</div>;
}
```

### 2. loader (데이터 로딩)

```typescript
// GET 요청 시 실행
export const loader = async ({ request, params }: LoaderFunctionArgs) => {
  // 서버에서만 실행됨
  const data = await fetchData();
  return json({ data });
};
```

### 3. action (데이터 변경)

```typescript
// POST, PUT, DELETE 등의 요청 시 실행
export const action = async ({ request }: ActionFunctionArgs) => {
  const formData = await request.formData();
  await saveData(formData);
  return redirect("/success");
};
```

### 4. ErrorBoundary

```typescript
// 에러 발생 시 렌더링되는 컴포넌트
export function ErrorBoundary() {
  const error = useRouteError();
  return <div>에러 발생: {error.message}</div>;
}
```

### 5. headers

```typescript
// 응답 헤더 커스터마이징
export const headers = ({ loaderHeaders, parentHeaders }) => {
  return {
    "Cache-Control": "public, max-age=3600",
  };
};
```

### 6. meta

```typescript
// SEO 메타데이터
export const meta: MetaFunction = () => {
  return [
    { title: "페이지 제목" },
    { name: "description", content: "페이지 설명" },
  ];
};
```

---

## 내비게이션

### 1. Link 컴포넌트

```typescript
import { Link } from "@remix-run/react";

export default function Navigation() {
  return (
    <nav>
      {/* 기본 링크 */}
      <Link to="/about">소개</Link>

      {/* 상대 경로 */}
      <Link to="./edit">수정</Link>
      <Link to="../">뒤로</Link>

      {/* Prefetch (마우스 오버 시 미리 로드) */}
      <Link to="/posts" prefetch="intent">
        포스트 보기
      </Link>

      {/* 활성 링크 스타일링 */}
      <Link
        to="/dashboard"
        className={({ isActive }) =>
          isActive ? "active" : ""
        }
      >
        대시보드
      </Link>
    </nav>
  );
}
```

### 2. NavLink (활성 상태 관리)

```typescript
import { NavLink } from "@remix-run/react";

export default function Sidebar() {
  return (
    <nav>
      <NavLink
        to="/dashboard"
        className={({ isActive, isPending }) =>
          isPending ? "pending" : isActive ? "active" : ""
        }
      >
        {({ isActive }) => (
          <>
            <Icon name={isActive ? "home-filled" : "home"} />
            대시보드
          </>
        )}
      </NavLink>
    </nav>
  );
}
```

### 3. 프로그래매틱 네비게이션

```typescript
import { useNavigate } from "@remix-run/react";

export default function MyComponent() {
  const navigate = useNavigate();

  const handleSuccess = () => {
    // 프로그래밍 방식으로 페이지 이동
    navigate("/success");
  };

  const handleBack = () => {
    navigate(-1); // 뒤로 가기
  };

  return (
    <div>
      <button onClick={handleSuccess}>완료</button>
      <button onClick={handleBack}>취소</button>
    </div>
  );
}
```

### 4. 라우트 파라미터 접근

```typescript
import { useParams } from "@remix-run/react";

export default function UserProfile() {
  const params = useParams();
  const userId = params.userId;

  return <div>사용자 ID: {userId}</div>;
}
```

---

## 라우팅 패턴 Best Practices

### 1. 폴더 구조 예시 (대규모 앱)

```
app/routes/
├── _index.tsx                           # 홈
├── _auth/                               # 인증 레이아웃
│   ├── route.tsx
│   ├── login.tsx
│   └── register.tsx
├── _app/                                # 앱 레이아웃
│   ├── route.tsx
│   ├── dashboard/
│   │   ├── route.tsx
│   │   ├── _index.tsx
│   │   ├── analytics.tsx
│   │   └── settings.tsx
│   └── projects/
│       ├── route.tsx
│       ├── _index.tsx
│       ├── $projectId/
│       │   ├── route.tsx
│       │   ├── _index.tsx
│       │   ├── settings.tsx
│       │   └── tasks.$taskId.tsx
│       └── new.tsx
└── api/                                 # API 라우트
    ├── webhooks.tsx
    └── health.tsx
```

### 2. 라우트 명명 규칙

```typescript
// ✅ 좋은 예
app/routes/users.$userId.tsx              // 명확한 파라미터 이름
app/routes/blog.posts.$slug.tsx           // 계층 구조 명확
app/routes/_auth.login.tsx                // 레이아웃 그룹핑

// ❌ 나쁜 예
app/routes/u.$id.tsx                      // 축약어 사용
app/routes/blog-posts-$slug.tsx           // 하이픈 사용
app/routes/authLogin.tsx                  // camelCase 사용
```

### 3. 중첩 라우팅 전략

```typescript
// 데이터가 필요한 레벨에서만 loader 사용
// app/routes/projects.$projectId/route.tsx
export const loader = async ({ params }: LoaderFunctionArgs) => {
  // 프로젝트 정보는 한 번만 로드
  const project = await db.project.findUnique({
    where: { id: params.projectId }
  });
  return json({ project });
};

// app/routes/projects.$projectId.tasks.$taskId.tsx
export const loader = async ({ params }: LoaderFunctionArgs) => {
  // 태스크 정보만 추가로 로드
  const task = await db.task.findUnique({
    where: { id: params.taskId }
  });
  return json({ task });
};

// 두 loader가 병렬로 실행되어 성능 최적화!
```

---

## 다음 단계

다음 문서에서는 Remix의 데이터 로딩과 액션 시스템을 상세히 알아보겠습니다:
- loader 함수 깊이 파기
- action 함수로 데이터 변경하기
- Form과의 통합
- 낙관적 UI 업데이트

**계속 학습하기**: [03-데이터-로딩과-액션.md](./03-데이터-로딩과-액션.md)
