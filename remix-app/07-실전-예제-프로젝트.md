# Remix ì™„ë²½ ê°€ì´ë“œ - 07. ì‹¤ì „ ì˜ˆì œ í”„ë¡œì íŠ¸

## ëª©ì°¨
1. [í”„ë¡œì íŠ¸ 1: Todo ì• í”Œë¦¬ì¼€ì´ì…˜](#í”„ë¡œì íŠ¸-1-todo-ì• í”Œë¦¬ì¼€ì´ì…˜)
2. [í”„ë¡œì íŠ¸ 2: ë¸”ë¡œê·¸ í”Œë«í¼](#í”„ë¡œì íŠ¸-2-ë¸”ë¡œê·¸-í”Œë«í¼)
3. [í”„ë¡œì íŠ¸ 3: ì¸ì¦ ì‹œìŠ¤í…œ](#í”„ë¡œì íŠ¸-3-ì¸ì¦-ì‹œìŠ¤í…œ)
4. [í”„ë¡œì íŠ¸ 4: ì „ììƒê±°ë˜ ì¥ë°”êµ¬ë‹ˆ](#í”„ë¡œì íŠ¸-4-ì „ììƒê±°ë˜-ì¥ë°”êµ¬ë‹ˆ)
5. [ë°°í¬ ê°€ì´ë“œ](#ë°°í¬-ê°€ì´ë“œ)
6. [Best Practices ìš”ì•½](#best-practices-ìš”ì•½)

---

## í”„ë¡œì íŠ¸ 1: Todo ì• í”Œë¦¬ì¼€ì´ì…˜

ì™„ì „í•œ CRUD ê¸°ëŠ¥ì„ ê°–ì¶˜ Todo ì•±ì„ êµ¬ì¶•í•©ë‹ˆë‹¤.

### 1. ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ

```prisma
// prisma/schema.prisma
model Todo {
  id        String   @id @default(cuid())
  title     String
  completed Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

### 2. Todos ëª©ë¡ í˜ì´ì§€

```typescript
// app/routes/todos._index.tsx
import { json, ActionFunctionArgs, LoaderFunctionArgs } from "@remix-run/node";
import { Form, useLoaderData, useFetcher } from "@remix-run/react";
import { db } from "~/utils/db.server";

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const url = new URL(request.url);
  const filter = url.searchParams.get("filter") || "all";

  const where = filter === "completed"
    ? { completed: true }
    : filter === "active"
    ? { completed: false }
    : {};

  const todos = await db.todo.findMany({
    where,
    orderBy: { createdAt: "desc" }
  });

  const stats = {
    total: await db.todo.count(),
    completed: await db.todo.count({ where: { completed: true } }),
    active: await db.todo.count({ where: { completed: false } })
  };

  return json({ todos, stats, filter });
};

export const action = async ({ request }: ActionFunctionArgs) => {
  const formData = await request.formData();
  const intent = formData.get("intent");

  switch (intent) {
    case "create": {
      const title = formData.get("title")?.toString();
      if (!title) {
        return json({ error: "ì œëª©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”" }, { status: 400 });
      }

      await db.todo.create({
        data: { title }
      });

      return json({ success: true });
    }

    case "toggle": {
      const id = formData.get("id")?.toString();
      const completed = formData.get("completed") === "true";

      await db.todo.update({
        where: { id },
        data: { completed }
      });

      return json({ success: true });
    }

    case "delete": {
      const id = formData.get("id")?.toString();

      await db.todo.delete({
        where: { id }
      });

      return json({ success: true });
    }

    case "clear-completed": {
      await db.todo.deleteMany({
        where: { completed: true }
      });

      return json({ success: true });
    }

    default:
      return json({ error: "Invalid intent" }, { status: 400 });
  }
};

export default function TodosIndex() {
  const { todos, stats, filter } = useLoaderData<typeof loader>();

  return (
    <div className="todo-app">
      <h1>Todo App</h1>

      {/* ìƒˆ Todo ì¶”ê°€ */}
      <Form method="post" className="add-todo">
        <input type="hidden" name="intent" value="create" />
        <input
          name="title"
          type="text"
          placeholder="í•  ì¼ì„ ì…ë ¥í•˜ì„¸ìš”..."
          autoFocus
        />
        <button type="submit">ì¶”ê°€</button>
      </Form>

      {/* í•„í„° */}
      <div className="filters">
        <Form method="get">
          <button name="filter" value="all" className={filter === "all" ? "active" : ""}>
            ì „ì²´ ({stats.total})
          </button>
          <button name="filter" value="active" className={filter === "active" ? "active" : ""}>
            ì§„í–‰ ì¤‘ ({stats.active})
          </button>
          <button name="filter" value="completed" className={filter === "completed" ? "active" : ""}>
            ì™„ë£Œ ({stats.completed})
          </button>
        </Form>
      </div>

      {/* Todo ëª©ë¡ */}
      <ul className="todo-list">
        {todos.map(todo => (
          <TodoItem key={todo.id} todo={todo} />
        ))}
      </ul>

      {/* ì™„ë£Œëœ í•­ëª© ì‚­ì œ */}
      {stats.completed > 0 && (
        <Form method="post">
          <input type="hidden" name="intent" value="clear-completed" />
          <button type="submit" className="clear-completed">
            ì™„ë£Œëœ í•­ëª© ì‚­ì œ
          </button>
        </Form>
      )}
    </div>
  );
}

// Todo ì•„ì´í…œ ì»´í¬ë„ŒíŠ¸
const TodoItem = ({ todo }) => {
  const fetcher = useFetcher();

  // ë‚™ê´€ì  UI
  const isCompleted = fetcher.formData
    ? fetcher.formData.get("completed") === "true"
    : todo.completed;

  const isDeleting =
    fetcher.state === "submitting" &&
    fetcher.formData?.get("intent") === "delete";

  if (isDeleting) {
    return null; // ì‚­ì œ ì¤‘ì´ë©´ ìˆ¨ê¹€
  }

  return (
    <li className={isCompleted ? "completed" : ""}>
      <fetcher.Form method="post">
        <input type="hidden" name="intent" value="toggle" />
        <input type="hidden" name="id" value={todo.id} />
        <input type="hidden" name="completed" value={(!isCompleted).toString()} />

        <button type="submit" className="checkbox">
          {isCompleted ? "âœ“" : "â—‹"}
        </button>
      </fetcher.Form>

      <span className="title">{todo.title}</span>

      <fetcher.Form method="post">
        <input type="hidden" name="intent" value="delete" />
        <input type="hidden" name="id" value={todo.id} />
        <button type="submit" className="delete">
          âœ•
        </button>
      </fetcher.Form>
    </li>
  );
};
```

---

## í”„ë¡œì íŠ¸ 2: ë¸”ë¡œê·¸ í”Œë«í¼

MDXë¥¼ ì‚¬ìš©í•œ ë¸”ë¡œê·¸ ì‹œìŠ¤í…œì…ë‹ˆë‹¤.

### 1. ë¸”ë¡œê·¸ í¬ìŠ¤íŠ¸ ëª©ë¡

```typescript
// app/routes/blog._index.tsx
import { json, LoaderFunctionArgs } from "@remix-run/node";
import { useLoaderData, Link, Form } from "@remix-run/react";
import { db } from "~/utils/db.server";

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const url = new URL(request.url);
  const search = url.searchParams.get("search") || "";
  const category = url.searchParams.get("category") || "";

  const where = {
    published: true,
    ...(search && {
      OR: [
        { title: { contains: search, mode: "insensitive" } },
        { excerpt: { contains: search, mode: "insensitive" } }
      ]
    }),
    ...(category && { category })
  };

  const [posts, categories] = await Promise.all([
    db.post.findMany({
      where,
      include: {
        author: {
          select: { name: true, avatar: true }
        },
        _count: {
          select: { comments: true }
        }
      },
      orderBy: { publishedAt: "desc" }
    }),
    db.post.findMany({
      where: { published: true },
      select: { category: true },
      distinct: ["category"]
    })
  ]);

  return json({
    posts,
    categories: categories.map(p => p.category),
    search,
    category
  });
};

export const meta: MetaFunction = () => {
  return [
    { title: "ë¸”ë¡œê·¸ - ê¸°ìˆ  ì•„í‹°í´" },
    { name: "description", content: "ìµœì‹  ê¸°ìˆ  íŠ¸ë Œë“œì™€ íŠœí† ë¦¬ì–¼" }
  ];
};

export default function BlogIndex() {
  const { posts, categories, search, category } = useLoaderData<typeof loader>();

  return (
    <div className="blog-container">
      <header className="blog-header">
        <h1>ê¸°ìˆ  ë¸”ë¡œê·¸</h1>

        {/* ê²€ìƒ‰ */}
        <Form method="get" className="search-form">
          <input
            name="search"
            type="search"
            placeholder="ê²€ìƒ‰..."
            defaultValue={search}
          />
          {category && (
            <input type="hidden" name="category" value={category} />
          )}
        </Form>
      </header>

      <div className="blog-layout">
        {/* ì‚¬ì´ë“œë°” */}
        <aside className="sidebar">
          <h3>ì¹´í…Œê³ ë¦¬</h3>
          <Form method="get">
            {search && <input type="hidden" name="search" value={search} />}
            <ul>
              <li>
                <button
                  name="category"
                  value=""
                  className={!category ? "active" : ""}
                >
                  ì „ì²´
                </button>
              </li>
              {categories.map(cat => (
                <li key={cat}>
                  <button
                    name="category"
                    value={cat}
                    className={category === cat ? "active" : ""}
                  >
                    {cat}
                  </button>
                </li>
              ))}
            </ul>
          </Form>
        </aside>

        {/* í¬ìŠ¤íŠ¸ ëª©ë¡ */}
        <main className="posts-grid">
          {posts.length === 0 ? (
            <p>í¬ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.</p>
          ) : (
            posts.map(post => (
              <article key={post.id} className="post-card">
                <Link to={`/blog/${post.slug}`} prefetch="intent">
                  {post.coverImage && (
                    <img src={post.coverImage} alt={post.title} />
                  )}

                  <div className="post-content">
                    <span className="category">{post.category}</span>
                    <h2>{post.title}</h2>
                    <p>{post.excerpt}</p>

                    <div className="post-meta">
                      <div className="author">
                        <img src={post.author.avatar} alt={post.author.name} />
                        <span>{post.author.name}</span>
                      </div>

                      <div className="stats">
                        <span>{formatDate(post.publishedAt)}</span>
                        <span>ğŸ’¬ {post._count.comments}</span>
                      </div>
                    </div>
                  </div>
                </Link>
              </article>
            ))
          )}
        </main>
      </div>
    </div>
  );
}

const formatDate = (date: string) => {
  return new Intl.DateTimeFormat("ko-KR", {
    year: "numeric",
    month: "long",
    day: "numeric"
  }).format(new Date(date));
};
```

### 2. ë¸”ë¡œê·¸ í¬ìŠ¤íŠ¸ ìƒì„¸

```typescript
// app/routes/blog.$slug.tsx
import { json, LoaderFunctionArgs } from "@remix-run/node";
import { useLoaderData, Link } from "@remix-run/react";
import { getMDXComponent } from "mdx-bundler/client";
import { useMemo } from "react";
import { db } from "~/utils/db.server";
import { bundleMDX } from "~/utils/mdx.server";

export const loader = async ({ params }: LoaderFunctionArgs) => {
  const post = await db.post.findUnique({
    where: { slug: params.slug },
    include: {
      author: true,
      comments: {
        include: { author: true },
        orderBy: { createdAt: "desc" }
      }
    }
  });

  if (!post || !post.published) {
    throw new Response("Not Found", { status: 404 });
  }

  // MDX ì»´íŒŒì¼
  const { code, frontmatter } = await bundleMDX({
    source: post.content
  });

  // ì¡°íšŒìˆ˜ ì¦ê°€
  await db.post.update({
    where: { id: post.id },
    data: { views: { increment: 1 } }
  });

  return json({ post, code, frontmatter });
};

export const meta: MetaFunction<typeof loader> = ({ data }) => {
  if (!data) return [{ title: "Post not found" }];

  const { post } = data;

  return [
    { title: `${post.title} - ë¸”ë¡œê·¸` },
    { name: "description", content: post.excerpt },
    { name: "author", content: post.author.name },
    { property: "og:title", content: post.title },
    { property: "og:description", content: post.excerpt },
    { property: "og:image", content: post.coverImage },
    { property: "og:type", content: "article" },
    { property: "article:published_time", content: post.publishedAt },
    { property: "article:author", content: post.author.name },
  ];
};

export default function BlogPost() {
  const { post, code } = useLoaderData<typeof loader>();

  // MDX ì»´í¬ë„ŒíŠ¸ ìƒì„±
  const Component = useMemo(() => getMDXComponent(code), [code]);

  return (
    <article className="blog-post">
      <header className="post-header">
        <Link to="/blog" className="back-link">
          â† ë¸”ë¡œê·¸ ëª©ë¡
        </Link>

        <span className="category">{post.category}</span>
        <h1>{post.title}</h1>

        <div className="post-meta">
          <div className="author-info">
            <img src={post.author.avatar} alt={post.author.name} />
            <div>
              <p className="author-name">{post.author.name}</p>
              <p className="post-date">{formatDate(post.publishedAt)}</p>
            </div>
          </div>

          <div className="stats">
            <span>ğŸ‘ {post.views}</span>
            <span>ğŸ’¬ {post.comments.length}</span>
          </div>
        </div>

        {post.coverImage && (
          <img
            src={post.coverImage}
            alt={post.title}
            className="cover-image"
          />
        )}
      </header>

      {/* MDX ì»¨í…ì¸  */}
      <div className="post-content">
        <Component />
      </div>

      {/* ëŒ“ê¸€ */}
      <section className="comments">
        <h2>ëŒ“ê¸€ {post.comments.length}</h2>

        <ul>
          {post.comments.map(comment => (
            <li key={comment.id} className="comment">
              <div className="comment-header">
                <img src={comment.author.avatar} alt={comment.author.name} />
                <div>
                  <p className="author-name">{comment.author.name}</p>
                  <p className="comment-date">{formatDate(comment.createdAt)}</p>
                </div>
              </div>
              <p className="comment-content">{comment.content}</p>
            </li>
          ))}
        </ul>
      </section>
    </article>
  );
}
```

---

## í”„ë¡œì íŠ¸ 3: ì¸ì¦ ì‹œìŠ¤í…œ

ì„¸ì…˜ ê¸°ë°˜ ì¸ì¦ì„ êµ¬í˜„í•©ë‹ˆë‹¤.

### 1. ì„¸ì…˜ ê´€ë¦¬

```typescript
// app/utils/session.server.ts
import { createCookieSessionStorage, redirect } from "@remix-run/node";
import bcrypt from "bcryptjs";
import { db } from "./db.server";

// ì„¸ì…˜ ìŠ¤í† ë¦¬ì§€ ìƒì„±
const sessionSecret = process.env.SESSION_SECRET;
if (!sessionSecret) {
  throw new Error("SESSION_SECRET must be set");
}

const storage = createCookieSessionStorage({
  cookie: {
    name: "app_session",
    secure: process.env.NODE_ENV === "production",
    secrets: [sessionSecret],
    sameSite: "lax",
    path: "/",
    maxAge: 60 * 60 * 24 * 30, // 30ì¼
    httpOnly: true
  }
});

export const createUserSession = async (userId: string, redirectTo: string) => {
  const session = await storage.getSession();
  session.set("userId", userId);

  return redirect(redirectTo, {
    headers: {
      "Set-Cookie": await storage.commitSession(session)
    }
  });
};

export const getUserSession = (request: Request) => {
  return storage.getSession(request.headers.get("Cookie"));
};

export const getUserId = async (request: Request): Promise<string | null> => {
  const session = await getUserSession(request);
  const userId = session.get("userId");
  return userId || null;
};

export const requireUserId = async (
  request: Request,
  redirectTo: string = new URL(request.url).pathname
) => {
  const userId = await getUserId(request);
  if (!userId) {
    const searchParams = new URLSearchParams([["redirectTo", redirectTo]]);
    throw redirect(`/login?${searchParams}`);
  }
  return userId;
};

export const getUser = async (request: Request) => {
  const userId = await getUserId(request);
  if (!userId) return null;

  const user = await db.user.findUnique({
    where: { id: userId },
    select: { id: true, email: true, name: true }
  });

  return user;
};

export const logout = async (request: Request) => {
  const session = await getUserSession(request);

  return redirect("/", {
    headers: {
      "Set-Cookie": await storage.destroySession(session)
    }
  });
};

export const register = async (email: string, password: string, name: string) => {
  const hashedPassword = await bcrypt.hash(password, 10);

  const user = await db.user.create({
    data: {
      email,
      name,
      password: hashedPassword
    }
  });

  return user;
};

export const login = async (email: string, password: string) => {
  const user = await db.user.findUnique({
    where: { email }
  });

  if (!user) return null;

  const isValid = await bcrypt.compare(password, user.password);
  if (!isValid) return null;

  return user;
};
```

### 2. ë¡œê·¸ì¸ í˜ì´ì§€

```typescript
// app/routes/login.tsx
import { json, ActionFunctionArgs, LoaderFunctionArgs } from "@remix-run/node";
import { Form, useActionData, useSearchParams, Link } from "@remix-run/react";
import { login, createUserSession, getUserId } from "~/utils/session.server";

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const userId = await getUserId(request);
  if (userId) {
    return redirect("/dashboard");
  }
  return json({});
};

export const action = async ({ request }: ActionFunctionArgs) => {
  const formData = await request.formData();
  const email = formData.get("email")?.toString();
  const password = formData.get("password")?.toString();
  const redirectTo = formData.get("redirectTo")?.toString() || "/dashboard";

  // ìœ íš¨ì„± ê²€ì¦
  const errors: Record<string, string> = {};

  if (!email || !email.includes("@")) {
    errors.email = "ì˜¬ë°”ë¥¸ ì´ë©”ì¼ì„ ì…ë ¥í•´ì£¼ì„¸ìš”";
  }

  if (!password || password.length < 6) {
    errors.password = "ë¹„ë°€ë²ˆí˜¸ëŠ” 6ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤";
  }

  if (Object.keys(errors).length > 0) {
    return json({ errors }, { status: 400 });
  }

  // ë¡œê·¸ì¸
  const user = await login(email, password);

  if (!user) {
    return json(
      { errors: { email: "ì´ë©”ì¼ ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤" } },
      { status: 401 }
    );
  }

  return createUserSession(user.id, redirectTo);
};

export default function Login() {
  const actionData = useActionData<typeof action>();
  const [searchParams] = useSearchParams();

  return (
    <div className="auth-container">
      <div className="auth-card">
        <h1>ë¡œê·¸ì¸</h1>

        <Form method="post">
          <input
            type="hidden"
            name="redirectTo"
            value={searchParams.get("redirectTo") || "/dashboard"}
          />

          <div className="form-group">
            <label htmlFor="email">ì´ë©”ì¼</label>
            <input
              id="email"
              name="email"
              type="email"
              autoComplete="email"
              required
              aria-invalid={actionData?.errors?.email ? true : undefined}
            />
            {actionData?.errors?.email && (
              <p className="error">{actionData.errors.email}</p>
            )}
          </div>

          <div className="form-group">
            <label htmlFor="password">ë¹„ë°€ë²ˆí˜¸</label>
            <input
              id="password"
              name="password"
              type="password"
              autoComplete="current-password"
              required
              aria-invalid={actionData?.errors?.password ? true : undefined}
            />
            {actionData?.errors?.password && (
              <p className="error">{actionData.errors.password}</p>
            )}
          </div>

          <button type="submit" className="btn-primary">
            ë¡œê·¸ì¸
          </button>
        </Form>

        <p className="auth-footer">
          ê³„ì •ì´ ì—†ìœ¼ì‹ ê°€ìš”?{" "}
          <Link to="/register">íšŒì›ê°€ì…</Link>
        </p>
      </div>
    </div>
  );
}
```

### 3. ë³´í˜¸ëœ ë¼ìš°íŠ¸

```typescript
// app/routes/dashboard.tsx
import { json, LoaderFunctionArgs } from "@remix-run/node";
import { useLoaderData, Form, Outlet } from "@remix-run/react";
import { requireUserId, getUser } from "~/utils/session.server";

export const loader = async ({ request }: LoaderFunctionArgs) => {
  await requireUserId(request); // ì¸ì¦ í•„ìˆ˜
  const user = await getUser(request);

  return json({ user });
};

export default function Dashboard() {
  const { user } = useLoaderData<typeof loader>();

  return (
    <div className="dashboard">
      <header className="dashboard-header">
        <h1>ëŒ€ì‹œë³´ë“œ</h1>

        <div className="user-menu">
          <span>ì•ˆë…•í•˜ì„¸ìš”, {user.name}ë‹˜</span>
          <Form action="/logout" method="post">
            <button type="submit">ë¡œê·¸ì•„ì›ƒ</button>
          </Form>
        </div>
      </header>

      <div className="dashboard-layout">
        <nav className="sidebar">
          <Link to="/dashboard">í™ˆ</Link>
          <Link to="/dashboard/profile">í”„ë¡œí•„</Link>
          <Link to="/dashboard/settings">ì„¤ì •</Link>
        </nav>

        <main className="dashboard-content">
          <Outlet />
        </main>
      </div>
    </div>
  );
}
```

---

## í”„ë¡œì íŠ¸ 4: ì „ììƒê±°ë˜ ì¥ë°”êµ¬ë‹ˆ

ì„¸ì…˜ì„ ì‚¬ìš©í•œ ì¥ë°”êµ¬ë‹ˆ ì‹œìŠ¤í…œì…ë‹ˆë‹¤.

### 1. ì¥ë°”êµ¬ë‹ˆ ì„¸ì…˜ ê´€ë¦¬

```typescript
// app/utils/cart.server.ts
import { createCookieSessionStorage } from "@remix-run/node";

const cartStorage = createCookieSessionStorage({
  cookie: {
    name: "cart",
    secure: process.env.NODE_ENV === "production",
    secrets: [process.env.SESSION_SECRET!],
    sameSite: "lax",
    path: "/",
    maxAge: 60 * 60 * 24 * 7, // 7ì¼
    httpOnly: true
  }
});

export type CartItem = {
  productId: string;
  quantity: number;
  price: number;
  name: string;
  image: string;
};

export const getCart = async (request: Request): Promise<CartItem[]> => {
  const session = await cartStorage.getSession(request.headers.get("Cookie"));
  return session.get("cart") || [];
};

export const addToCart = async (request: Request, item: CartItem) => {
  const session = await cartStorage.getSession(request.headers.get("Cookie"));
  const cart: CartItem[] = session.get("cart") || [];

  const existingItem = cart.find(i => i.productId === item.productId);

  if (existingItem) {
    existingItem.quantity += item.quantity;
  } else {
    cart.push(item);
  }

  session.set("cart", cart);

  return {
    cart,
    headers: {
      "Set-Cookie": await cartStorage.commitSession(session)
    }
  };
};

export const removeFromCart = async (request: Request, productId: string) => {
  const session = await cartStorage.getSession(request.headers.get("Cookie"));
  const cart: CartItem[] = session.get("cart") || [];

  const newCart = cart.filter(item => item.productId !== productId);

  session.set("cart", newCart);

  return {
    cart: newCart,
    headers: {
      "Set-Cookie": await cartStorage.commitSession(session)
    }
  };
};

export const updateQuantity = async (
  request: Request,
  productId: string,
  quantity: number
) => {
  const session = await cartStorage.getSession(request.headers.get("Cookie"));
  const cart: CartItem[] = session.get("cart") || [];

  const item = cart.find(i => i.productId === productId);

  if (item) {
    if (quantity <= 0) {
      return removeFromCart(request, productId);
    }
    item.quantity = quantity;
  }

  session.set("cart", cart);

  return {
    cart,
    headers: {
      "Set-Cookie": await cartStorage.commitSession(session)
    }
  };
};

export const clearCart = async (request: Request) => {
  const session = await cartStorage.getSession(request.headers.get("Cookie"));
  session.set("cart", []);

  return {
    headers: {
      "Set-Cookie": await cartStorage.commitSession(session)
    }
  };
};
```

### 2. ì¥ë°”êµ¬ë‹ˆ í˜ì´ì§€

```typescript
// app/routes/cart.tsx
import { json, ActionFunctionArgs, LoaderFunctionArgs } from "@remix-run/node";
import { useLoaderData, Form, useFetcher } from "@remix-run/react";
import {
  getCart,
  updateQuantity,
  removeFromCart,
  clearCart
} from "~/utils/cart.server";

export const loader = async ({ request }: LoaderFunctionArgs) => {
  const cart = await getCart(request);

  const subtotal = cart.reduce(
    (sum, item) => sum + item.price * item.quantity,
    0
  );

  const shipping = subtotal > 50 ? 0 : 5;
  const tax = subtotal * 0.1;
  const total = subtotal + shipping + tax;

  return json({ cart, subtotal, shipping, tax, total });
};

export const action = async ({ request }: ActionFunctionArgs) => {
  const formData = await request.formData();
  const intent = formData.get("intent");

  switch (intent) {
    case "update-quantity": {
      const productId = formData.get("productId")?.toString()!;
      const quantity = parseInt(formData.get("quantity")?.toString() || "1");

      const { cart, headers } = await updateQuantity(request, productId, quantity);

      return json({ cart }, { headers });
    }

    case "remove": {
      const productId = formData.get("productId")?.toString()!;

      const { cart, headers } = await removeFromCart(request, productId);

      return json({ cart }, { headers });
    }

    case "clear": {
      const { headers } = await clearCart(request);

      return json({ cart: [] }, { headers });
    }

    default:
      return json({ error: "Invalid intent" }, { status: 400 });
  }
};

export default function Cart() {
  const { cart, subtotal, shipping, tax, total } = useLoaderData<typeof loader>();

  if (cart.length === 0) {
    return (
      <div className="empty-cart">
        <h1>ì¥ë°”êµ¬ë‹ˆê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤</h1>
        <Link to="/products">ì‡¼í•‘ ê³„ì†í•˜ê¸°</Link>
      </div>
    );
  }

  return (
    <div className="cart-container">
      <h1>ì¥ë°”êµ¬ë‹ˆ</h1>

      <div className="cart-layout">
        {/* ì¥ë°”êµ¬ë‹ˆ ì•„ì´í…œ */}
        <div className="cart-items">
          {cart.map(item => (
            <CartItem key={item.productId} item={item} />
          ))}

          <Form method="post">
            <input type="hidden" name="intent" value="clear" />
            <button type="submit" className="clear-cart">
              ì¥ë°”êµ¬ë‹ˆ ë¹„ìš°ê¸°
            </button>
          </Form>
        </div>

        {/* ì£¼ë¬¸ ìš”ì•½ */}
        <div className="order-summary">
          <h2>ì£¼ë¬¸ ìš”ì•½</h2>

          <dl>
            <dt>ì†Œê³„</dt>
            <dd>${subtotal.toFixed(2)}</dd>

            <dt>ë°°ì†¡ë¹„</dt>
            <dd>{shipping === 0 ? "ë¬´ë£Œ" : `$${shipping.toFixed(2)}`}</dd>

            <dt>ì„¸ê¸ˆ</dt>
            <dd>${tax.toFixed(2)}</dd>

            <dt className="total">í•©ê³„</dt>
            <dd className="total">${total.toFixed(2)}</dd>
          </dl>

          <Link to="/checkout" className="btn-primary btn-block">
            ê²°ì œí•˜ê¸°
          </Link>
        </div>
      </div>
    </div>
  );
}

// ì¥ë°”êµ¬ë‹ˆ ì•„ì´í…œ ì»´í¬ë„ŒíŠ¸
const CartItem = ({ item }) => {
  const fetcher = useFetcher();

  const quantity = fetcher.formData?.get("quantity")
    ? parseInt(fetcher.formData.get("quantity")!.toString())
    : item.quantity;

  return (
    <div className="cart-item">
      <img src={item.image} alt={item.name} />

      <div className="item-details">
        <h3>{item.name}</h3>
        <p className="price">${item.price.toFixed(2)}</p>
      </div>

      <fetcher.Form method="post" className="quantity-control">
        <input type="hidden" name="intent" value="update-quantity" />
        <input type="hidden" name="productId" value={item.productId} />

        <button
          name="quantity"
          value={quantity - 1}
          disabled={quantity <= 1}
        >
          -
        </button>

        <span>{quantity}</span>

        <button
          name="quantity"
          value={quantity + 1}
        >
          +
        </button>
      </fetcher.Form>

      <p className="item-total">
        ${(item.price * quantity).toFixed(2)}
      </p>

      <fetcher.Form method="post">
        <input type="hidden" name="intent" value="remove" />
        <input type="hidden" name="productId" value={item.productId} />
        <button type="submit" className="remove-item">
          âœ•
        </button>
      </fetcher.Form>
    </div>
  );
};
```

---

## ë°°í¬ ê°€ì´ë“œ

### 1. Vercel ë°°í¬

```bash
# Vercel CLI ì„¤ì¹˜
pnpm add -g vercel

# ë¡œê·¸ì¸
vercel login

# ë°°í¬
vercel

# í”„ë¡œë•ì…˜ ë°°í¬
vercel --prod
```

### 2. Fly.io ë°°í¬

```bash
# Fly CLI ì„¤ì¹˜
curl -L https://fly.io/install.sh | sh

# ë¡œê·¸ì¸
fly auth login

# ì•± ìƒì„±
fly launch

# ë°°í¬
fly deploy
```

### 3. Railway ë°°í¬

```bash
# Railway CLI ì„¤ì¹˜
npm i -g @railway/cli

# ë¡œê·¸ì¸
railway login

# í”„ë¡œì íŠ¸ ì´ˆê¸°í™”
railway init

# ë°°í¬
railway up
```

---

## Best Practices ìš”ì•½

### 1. ë¼ìš°íŒ…
- âœ… ì¤‘ì²© ë¼ìš°íŒ…ì„ í™œìš©í•˜ì—¬ ë ˆì´ì•„ì›ƒ ì¬ì‚¬ìš©
- âœ… ë™ì  ì„¸ê·¸ë¨¼íŠ¸ëŠ” ëª…í™•í•œ ì´ë¦„ ì‚¬ìš©
- âœ… Pathless ë¼ìš°íŠ¸ë¡œ ê³µí†µ ë¡œì§ ê·¸ë£¹í•‘

### 2. ë°ì´í„° ë¡œë”©
- âœ… loaderëŠ” ì„œë²„ì—ì„œë§Œ ì‹¤í–‰ë˜ë¯€ë¡œ DB ì§ì ‘ ì ‘ê·¼ ê°€ëŠ¥
- âœ… ë³‘ë ¬ ë°ì´í„° ë¡œë”© í™œìš©
- âœ… ì ì ˆí•œ HTTP ìºì‹± ì „ëµ ì‚¬ìš©

### 3. í¼ ì²˜ë¦¬
- âœ… Remix Form ì»´í¬ë„ŒíŠ¸ ì‚¬ìš©
- âœ… ì„œë²„ ì‚¬ì´ë“œ ìœ íš¨ì„± ê²€ì¦ í•„ìˆ˜
- âœ… ë‚™ê´€ì  UIë¡œ ì‚¬ìš©ì ê²½í—˜ í–¥ìƒ

### 4. ì—ëŸ¬ ì²˜ë¦¬
- âœ… ê° ë¼ìš°íŠ¸ì— ErrorBoundary êµ¬í˜„
- âœ… ì˜ë¯¸ìˆëŠ” ì—ëŸ¬ ë©”ì‹œì§€ ì œê³µ
- âœ… í”„ë¡œë•ì…˜ì—ì„œ ì—ëŸ¬ ë¡œê¹…

### 5. ì„±ëŠ¥ ìµœì í™”
- âœ… Prefetchë¡œ ì²´ê° ì†ë„ í–¥ìƒ
- âœ… ì´ë¯¸ì§€ ìµœì í™” ë° lazy loading
- âœ… ë¶ˆí•„ìš”í•œ ì¬ê²€ì¦ ë°©ì§€

### 6. SEO
- âœ… meta í•¨ìˆ˜ë¡œ ë™ì  ë©”íƒ€ íƒœê·¸
- âœ… ì ì ˆí•œ ìºì‹± í—¤ë” ì„¤ì •
- âœ… Sitemap ë° robots.txt ì œê³µ

---

## í•™ìŠµ ì™„ë£Œ!

ì¶•í•˜í•©ë‹ˆë‹¤! Remixì˜ ëª¨ë“  í•µì‹¬ ê°œë…ì„ í•™ìŠµí•˜ì…¨ìŠµë‹ˆë‹¤. ğŸ‰

### ë‹¤ìŒ ë‹¨ê³„
1. **ì‹¤ì „ í”„ë¡œì íŠ¸ êµ¬ì¶•**: ìœ„ì˜ ì˜ˆì œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìì‹ ë§Œì˜ í”„ë¡œì íŠ¸ ì‹œì‘
2. **Remix ê³µì‹ ë¬¸ì„œ**: https://remix.run/docs
3. **ì»¤ë®¤ë‹ˆí‹°**: Remix Discord, GitHub Discussions ì°¸ì—¬
4. **ê³ ê¸‰ ì£¼ì œ**:
   - Server-Sent Events (SSE)
   - WebSocket í†µí•©
   - ë§ˆì´í¬ë¡œí”„ë¡ íŠ¸ì—”ë“œ
   - ëª¨ë…¸ë ˆí¬ êµ¬ì„±

**Happy Coding with Remix! ğŸš€**
